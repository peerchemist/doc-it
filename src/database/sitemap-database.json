{
    "": { "title": "V Systems Blockchain | The Blockchain for Real World Applications*" },
    "/overview": {
        "title": "What is V Systems?",
        "text": "import { Divider, ImageGrid } from '../app/components';\nimport DesignSystemImage from '../app/assets/design-system.jpg';\n\n<!-- KEYWORDS: Overview of V Systems Documentation  -->\n\n# Welcome to V Systems Documentation\n\n<EmbeddedYouTubePlayer videoID={`wwukiFsUsq0`} />\n\nV Systems is a blockchain platform that supports the efficient and agile development of decentralized applications.\n\nV Systems is designed for real world use cases and has a set of composable “no code” smart contract templates that cover the vast majority of real-world smart contract use cases without any need for security audits.\n\n\n## Development\n\nV Systems is a layer-1 public blockchain. Our blockchain development platform makes the technology as user-friendly as possible and greatly ease the burden for developers while exceeding project requirements.\n\n-   To learn about V Systems, check out our [Main Website](https://www.v.systems/).\n-   To dive straight into development, see our [Development Resources](/get-started/where-to-begin) page.\n\n<Divider />\n\n# About this site\n\nThis site will provide you with everything you need to get started with writing applications with the V Systems Protocol:\n\n-   Pre-Requisites, a breakdown of the [V Systems Stack](/get-started/vsys-stack) you will need before writing any code.\n-   Information Guides, including information on starting a [New Project](/get-started/where-to-begin) and the different types of applications you can build\n-   DevNet Guides, including how to set up a [Development Environment](/get-started/where-to-begin), how to start a new project in any of our supported technologies\n-   Code Examples/[Quick Tutorials](/design/intro) explaining how to use our V Systems templated smart contracts.\n-   A [Smart Contracts](/resources) page that describe all the different smart contracts and functionality.\n"
    },
    "/get-started/vsys-stack": {
        "title": "V Systems Stack",
        "text": "import { Divider } from '../../app/components';\n\n<!-- KEYWORDS: VSYS Stack New Project Guide -->\n\n# Start Building on V Systems Blockchain\n\nV Systems, our approach to application development dictates that developers should not need to write blockchain related code and that smart contracts should not require third-party security audits because our templates have already been audited.\n\n**Our stack has four layers.**\n\n## V Systems Blockchain Knowledge ( Layer-1 )\n\nThe V Systems blockchain is the lowest layer of the VSYS stack. It is where primary consensus happens, and it enables the no-code smart contracts, database API, and application specific side chains.\n\n## Database API\n\nFor stateful applications, our database API provides a simple, immutable, user funded way of storing application state. Optionally app development teams can choose to fund storage of application state using the database API. It is very flexible.\n\n## No Code Smart Contracts\n\nOur new code smart contracts enable developers to compose powerful functionality without needing to write any smart contract code. The smart contracts should not require third-party security audits because our templates have already been audited.\n\n## No Code Application Sidechains\n\nCurrently, we are developing no code application specific side chains. Basically, these combine the no-code smart contracts and the Database API but provide their very own chain. Chains built in this manner will gain access to instant liquidity from a DEX built into the V Systems blockchain.\n\n<Divider />\n\n\n# Deciding What Kind of Application to Build\n\nWith a new project, the nature of the project often determines which type of application you will need.\n\n## This Project is Replacing an Existing Product\n\nThink about the existing product and how it is used. Gather feedback from existing users and identify areas for improvement.\n\nIn general, you will want to at least provide the same type of application as before (unless user feedback suggests that it's not what they need). If you had a web application before, you may want to build a responsive web application this time. Alternatively, you may want to expand on the existing product by offering a mobile application.\n\n## This is a Brand New Product (never before seen)\n\nThink about how the product will be used. Does it offer features that users will want to access on the go? Is it going to be actively used in the field, or is it something users will more likely use from their desk?\n\nIn general, you can't go wrong with a web application. If you do your due diligence and design a properly responsive application, you will be able to access it from any connected device, including mobile. If you suspect that the primary mode of interacting with the application will be from a mobile device or if the application needs to work offline, you may want to consider building a dedicated mobile app.\n\n"
    },
    "/get-started/where-to-begin": {
        "title": "Where to Begin?",
        "text": "import { Divider } from '../../app/components';\n\n<!-- KEYWORDS: Where to Begin Building on V Systems Blockchain -->\n\n# Getting Started\n\nIn this documentation, we are going to run a dev net on your local machine with **2 nodes where one acts as a minter and the other acts as a normal peer.**\n\n> VSYS uses the SPoS consensus mechanism where there are up to 60 nodes that act as supernodes(minter) and have the privilege to generate new blocks. Other nodes are normal peers in the net.\n\n> There are 3 kinds of net as listed below: \n-   Main net: the public production net where everything happens counts.\n- Test net: the public staging net that simulates the main net for testing purposes(e.g. QA test of DApps before deploying to the main net).\n- Dev net: the private local net for developing purposes(e.g. quickly verify features during developing)\n\n<Divider/>\n\n# Build Your Own V Systems Dev Net\n## Prerequisites\n\nEnsure that you have:\n- installed [Docker](https://www.docker.com/get-started) on your local machine\n- installed [Scala & sbt](https://docs.scala-lang.org/getting-started/index.html) on your local machine\n\n## Generate TestNet Wallet\n\n1. Git clone the v-wallet-generator repo & go to the root directory.\n\n```python:\ngit clone git@github.com:virtualeconomy/v-wallet-generator.git\ncd v-wallet-generator\n```\n\n2. Enter sbt shell & run\n```python:\n$ sbt\nsbt:walletgenerator> run --testnet --count 10\n```\n\nCollect the output and save it as a file where you have something like below. We are going to need it later.\n\n```python:\n-----------------------------------------------------------------------------------------------------------------------------------------------------\nIMPORTANT - COPY OR MEMORIZE THE SEED PHRASE BELOW FOR KEY RECOVERY!!!\nseed         : foam render square glide social breeze bamboo miracle quick depart wife gravity antique cry offer\n------------------------------------------------------------------------------------------------------------------------------------------------------\naddress #    : 0\naddress      : AU1kWYYThZCiSZC9qPifFpGAoxuut5p2ELv\npublic key   : GdJMs3FiB3xBDm3P5a76aPM4sGm4NbkXVDUjm1YYFhDu\nprivate key  : Cu5EWAKKH4HHART8sKfxB1rKXBghG8uNL5dynw39mC5z\naccount seed : Afqc3coMs5knqmwYnaSgYKqMeVVp487ShBg3hj3AuSZj\n------------------------------------------------------------------------------------------------------------------------------------------------------\naddress #    : 1\naddress      : AUAA4PxhoYWxhdAt5PbCvZArSnFeQytAWet\npublic key   : AttEU9KBEQCfGawQ5i86wCFA4Uvy1qBWY5WdXm5A8uHd\nprivate key  : 4n32Erz3YGX9XCnFQACQAiRjA9oy8iNEN6pnnEziULBh\naccount seed : 5FL5KhSrWdcG5dsAe2fTSASzuuoEAf25hmVZLXsX6ZUD\n------------------------------------------------------------------------------------------------------------------------------------------------------\n... (and more)\n```\n\n## Generate Gensis Block Data\n\n> A Genesis Block is the first block of the blockchain network. It has a list of initial accounts in it.\n\n1. Git clone the <mark>v-systems</mark> repo & go to the root directory.\n\n```python:\ngit clone git@github.com:virtualeconomy/v-systems.git\ncd v-systems\n```\n\n2. Update the value <mark>wallet_addresses</mark> in <mark>src/test/scala/tools/DevelopnetGenesisBlockGenerator.scala</mark> with addresses generated in the last step.\n\n3. Run <mark>DevelopnetGenesisBlockGenerator.scala</mark> at the root of project <mark>v-systems</mark>\n\n```python:\nsbt \"test:runMain tools.DevelopnetGenesisBlockGenerator\"\n```\n\nCollect the output and save it as a file where you have something like below. We are going to need it later.\n\n```python:\n[info] GenesisSettings:\n[info]  timestamp: 1606373598254137883\n[info]  blockTimestamp: 1606373598254137883\n[info]  averageBlockDelay: 60 seconds\n[info]  initialBalance: 500000000000000000\n[info]  initialMintTime: 1606373598000000000\n[info]  signature: Some(3yzHvLWnzug8x5ut1M3fftbcy3aWgbYCmyYtSp2A3vLB6aAVvbDnHARfTcuzDygaEGE6qgJHb4cZ8fGjuj9b9ChF)\n[info]  transactions:\n[info]    GenesisTransactionSettings(ATwAPYdriV1aRXAWYmLViW7Y6K5Jb5bZDkT,50000000000000000,0)\n[info]    GenesisTransactionSettings(AUCUg4dFgn52U2PgZb9YhehBXnSqp8EMRqH,50000000000000000,6)\n[info]    GenesisTransactionSettings(AU6sMeLdsswqDQrw4RDo5PVxdGh1v6JDv6t,50000000000000000,12)\n[info]    GenesisTransactionSettings(ATyssF9z8RQRX9UJwwJLm5SbFEFGqEzYSnb,50000000000000000,18)\n[info]    GenesisTransactionSettings(AUDwJXq3esDqasmyVrN5FpXr7iFbKSXL8E2,50000000000000000,24)\n[info]    GenesisTransactionSettings(AUA1pbbCFyFSte38uENPXSAhZa7TH74V2Tc,50000000000000000,30)\n[info]    GenesisTransactionSettings(AU7fEwBgHpe6oeH1iuo2mE5TMCrBxPR8LFc,50000000000000000,36)\n[info]    GenesisTransactionSettings(ATxtBDygMvWtvh9xJaGQn5MdaHsbuQxbjiG,50000000000000000,42)\n[info]    GenesisTransactionSettings(AU1EWbfR8mTwbvzgnY8wdpLy3vEvF64WSEE,50000000000000000,48)\n[info]    GenesisTransactionSettings(AU4u8erPGstSFSCU1U6cLyFNeR9Cbk1x8eU,50000000000000000,54)\n```\n\n## Generate Gensis Block Data\n\n> The node exposes a list of RESTful APIs for users to interact with the blockchain. To get a feel, see the public Swagger API doc for our test net. <br/>\n    You may have noticed that some endpoints have a little lock on the right side. It means the endpoint is privileged and has to be used with an API key(i.e. only people with the API key can call it). <br/>\n    The hash of the key is planted into the node’s configuration hence the node can verify the key\n\n\n```python:\ncurl \\\n -X POST \\\n -H \"Content-Type: text/plain\" \\\n --data \"my_api_key\" \\\n http://veldidina.vos.systems:9928/utils/hash/secure\n ```\n\n You can replace <mark>my_api_key</mark> with anything you like. Collect the hash and we are going to need it later.\n\nBelow is an example response\n\n```python:\n{\n  \"message\" : \"my_api_key\",\n  \"hash\" : \"7AshJ286oqdpTYoFbEWXDEqY313qYiaFHMvKYTGXsgwY\"\n}\n```\n\n## Compose Node Configuration\n\nDownload the template configuration file attached below and update for the minter node & peer node accordingly. Fields to update are decorated with a comment <mark># TODO</mark> above so you can quickly navigate to them by searching <mark># TODO</mark> in a text editor.\n\nThe minter & the peer share most parts of the configuration. The key difference lies in the ports they use.\n\n1. For RESTful API ports, minter uses <mark>8080</mark>, peer uses <mark>8000</mark>\n\n2. For nodes communication ports, minter uses <mark>19923</mark>, peer uses <mark>19924</mark> \n\n\n## Launch Docker Container\n\n1. Download the Dockerfile attached below and build the image locally\n\n```python:\ndocker build -t vsys -f {path_to_the_dockerfile} .\n```\n\nThe VSYS node jar version is by default 0.4.1. It can be overridden by using the --build-arg flag when building.\n\n```python:\ndocker build -t vsys -f {path_to_the_dockerfile} --build-arg VSYS_VER=x.y.z .\n```\n\n2. Launch a container for minter\n\n```python:\ndocker run -it \\\n-p 8080:8080 \\\n-p 19923:19923 \\\n--name minter \\\n--mount type=bind,source=\"/absolute/path/to/your/minter.conf\",target=\"/vsys/vsys.conf\" \\\nvsys\n```\n\n3. Launch a container for peer\n\n```python:\ndocker run -it \\\n-p 8000:8000 \\\n-p 19924:19924 \\\n--name peer \\\n--mount type=bind,source=\"/absolute/path/to/your/peer.conf\",target=\"/vsys/vsys.conf\" \\\nvsys\n```\n\n## Verify the Dev Net Runs Properly\n\n1. Type <mark>127.0.0.1:8080</mark> & <mark>127.0.0.1:8000</mark> in the browser and see if the Swagger API doc shows up.\n\n2. Call <mark>curl -X GET http://127.0.0.1:8080/blocks/height</mark> and see if the height increments by ONE per minute.  Below is a quick shell script to query the height every 10 seconds.\n\n```python:\nwhile true; do\n  curl -X GET http://127.0.0.1:8080/blocks/height\n  sleep 10\ndone\n```"
    },
    "/get-started/quick-tutorials": {
        "title": "Quick Tutorials",
        "text": "<!-- KEYWORDS: web application introduction framework -->\n\n# Quick Tutorials\n\nOur developers are in the middle of creating new tutorials for everyone to use. We'll be back soon."
    },
    "/get-started/smart-contracts/token-contract": {
        "title": "Token Contract",
        "text": "<!-- KEYWORDS: Token Contract Smart Contract -->\n\n# Token Contract\n\n## Introduction\n\nA **Token Contract** allows users to set up their own tokens on an existing blockchain (e.g. the VSYS chain in our case).\n\nA token is a logical entity on the blockchain. It can represent basically everything that can be stored in a database. Be it a fiat currency like USD, financial assets like a share in a company, or even reputation points of an online platform.\n\nA contract can be thought of as a class in OOP with a bunch of methods. After creating an instance of a contract, functions can be called by sending the function index and arguments(A.K.A Data Stack) to the contract instance.\n\n\n\n> If you are new to blockchain, it is highly recommended to quickly go through resources in External Resources of Topics in Blockchain to equip yourself with fundamental knowledge before going further.\n\n\n\nThere are two types of tokens, namely token <mark>with split</mark> and token <mark>without split</mark> in VSYS. The key difference is **if a token can be further broken down into smaller pieces (and vice versa)**. For example, Bitcoin is token with spilt as it is possible to buy 0.1 Bitcoin while a song is token without split as it makes no sense to buy half a song.\n\nNote that **one instance of Token Contract can define only ONE kind of token for now** though theoretically, it is possible to have multiple kinds of tokens within a contract.\n\n\n## Available Functions for Token Contract\n\n| Executable functions \t| Function ID for Token without Split \t| Function ID for Token with Split \t|             Input types             \t|             Input Types             \t|                          Description                          \t| Available Only to the Address with the Issuing Right \t|\n|:--------------------:\t|:-----------------------------------:\t|:--------------------------------:\t|:-----------------------------------:\t|:-----------------------------------:\t|:-------------------------------------------------------------:\t|:----------------------------------------------------:\t|\n|      TotalSupply     \t|                  7                  \t|                 8                \t|                  ()                 \t|                  ()                 \t|                       Currently not used                      \t|                                                      \t|\n|       MaxSupply      \t|                  8                  \t|                 9                \t|                  ()                 \t|                  ()                 \t|                       Currently not used                      \t|                                                      \t|\n|       GetIssuer      \t|                  10                 \t|                11                \t|                  ()                 \t|                  ()                 \t|                       Currently not used                      \t|                                                      \t|\n|       Supersede      \t|                  0                  \t|                 0                \t|            (\"newIssuer\")            \t|              (address)              \t| Transfer the issuing right of the contract to another account \t|                                                      \t|\n|       BalanceOf      \t|                  9                  \t|                20                \t|             (\"address\")             \t|              (address)              \t|                       Currently not used                      \t|                                                      \t|\n|         Send         \t|                  3                  \t|                 4                \t|       (\"recipient\", \"amount\")       \t|          (address, amount)          \t|                          Send tokens                          \t|                                                      \t|\n|       Transfer       \t|                  4                  \t|                 5                \t|  (\"sender\", \"recipient\", \"amount\")  \t|      (address, address, amount)     \t|            Transfer tokens from sender to recipient           \t|                                                      \t|\n|        Deposit       \t|                  5                  \t|                 6                \t|   (\"sender\", \"contract\", \"amount\")  \t| (address, contract_account, amount) \t|              Deposit tokens into another contract             \t|                                                      \t|\n|         Issue        \t|                  1                  \t|                 1                \t|              (\"amount\")             \t|               (amount)              \t|                        Issue new tokens                       \t|                          Yes                         \t|\n|        Destroy       \t|                  2                  \t|                 2                \t|              (\"amount\")             \t|               (amount)              \t|                         Destroy tokens                        \t|                          Yes                         \t|\n|         Split        \t|                 N/A                 \t|                 3                \t|             (\"newUnit\")             \t|               (amount)              \t|                        Update the unit                        \t|                          Yes                         \t|\n|       Withdraw       \t|                  6                  \t|                 7                \t| (\"contract\", \"recipient\", \"amount\") \t| (contract_account, address, amount) \t|             Withdraw tokens from another contract             \t|                                                      \t|\n\n\n## FAQ\n\n### What is \"Unit\"?\n\n“Unit” is the granularity of splitting a token. It can be thought of as the smallest denomination available. Let’s take real-world money as an example, if the unit is set to 100, it means the smallest denomination is a cent, and 100 cents is a dollar.\n\n**“Unit” exists to use only integers to represent splitted tokens(e.g. 0.1) as float computation is uncertainty-prone**. If we set unit == 100, 1.5 tokens are actually stored as 150 in the blockchain.\n\n\n### Difference between the function \"Send\" & \"Transfer\"?\n\n**Transfer** is the most powerful function as it allows customising the sender & the recipient at the same time. \n\n> For contract functions, the contract instance would verify the invoker as per its pre-defined whitelist. Actions defined in the function would be taken only if the invoker is proved valid.\n\nFunction <mark>Send</mark>, <mark>Deposit</mark>, and <mark>Withdraw</mark> can be considered as special cases of <mark>Transfer</mark> and is built on top ofTransfer.\n\n<mark>Send</mark>: The sender is set to the invoker itself. The recipient has to be an account.\n\n<mark>Deposit</mark>: The sender has to be the invoker itself. The recipient has to be a contract\n\n<mark>Withdraw</mark>: The sender has to be a contract. The recipient has to be the invoker itself.\n\nCalling <mark>Transfer</mark> with the sender and the recipient both set to a contract is NOT supported yet but theoretically possible.\n\n> It is discouraged to call function <mark>Transfer</mark> directly in application codes. Call more specialised function like <mark>Send</mark>, <mark>Deposit</mark>, <mark>Withdraw</mark> instead.\n\n\n## Tutorial\n\nIn this tutorial, we are going to create a new Token Contract with **splittable** tokens and play around with it. Token Contract with **unsplittable** tokens is basically the same except that it does not have the split function.\n\nThis tutorial is built upon the [Python SDK](https://github.com/virtualeconomy/pyvsystems) of V Systems Github.\n\n### 0. Pre-Requisites\n\n    Ensure that you have:\n\n    1. Tried out the Swagger interactive API doc for RESTful APIs of the Testnet. It is a user-friendly tool to query the status and verify the changes on the chain\n\n    2. Gone through the tutorial of building your own VSYS dev net and have your Testnet wallet seed available after it\n\n    3. Topped up sufficient VSYS coins to the devnet(http://veldidina.vos.systems:9928/) as the gas fee for the tutorial. Gas fee for some operations:\n\n        - Create a contract: 100 VSYS\n\n        - Execute a contract function: 0.3 VSYS\n\n    4. Installed Python 3.7+\n\n    5. installed pipenv via which we will install the Python SDK of V Systems\n\n\n\n### 1. Get the Example Codes &amp; Set Up Environment\n\n Clone the repository of example codes\n\n```python:\ngit clone git@github.com:virtualeconomy/py-v-sdk-examples.git\n```\n\n\nGo to the root directory of the repo and install dependencies\n```python:\npipenv install\n```\n\nFill in your Testnet wallet seed in main.py\n\n```python:\nNODE_HOST = \"http://veldidina.vos.systems:9928\" # The testnet\nWALLET_SEED = \"\" # <--- Fill in your testnet wallet seed here\n```\n\nLeave only the playground function try_token_contract() in the main function and comment out other playground functions.\n\n```python:\ndef main():\n    try_token_contract()\n    # try_atomic_swap_contract()\n```\n\n> Statements for common operations are provided in the playground function <mark>try_token_contract</mark> and can be commented out on demand when playing around.\n\n\n### 2. Register a Token Contract\n\nComment out everything in the playground function try_token_contract() to leave only the snippet below.\n\n\n```python:\n# Register a Token Contract with splittable tokens\n# Note that it registers a new Token Contract every time it runs\ntc = TokenContract.register(\n    by=ACNT_0,\n    max=1_000_000_000,\n    unit=1,\n    split=True,\n)\n```\n\nRun it by <mark>python main.py</mark>\n\nA Python dictionary will be printed to the console. Find the contractId in it and fill it to the variable <mark>tok_ctrt_id</mark>\n\n```python:\n# The contract id found in the output of registering the Token Contract\ntok_ctrt_id = \" \" # <--- Fill in here\n```\n\nWe can call the endpoint <mark>/contract/info/{contractId}</mark> to verify that the contract is created through the [Swagger interactive API doc for RESTful APIs of the Testnet](http://veldidina.vos.systems:9928/api-docs/index.html)\n\nBelow is an example response body:\n\n```python:\n{\n  \"contractId\": \"CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3\",\n  \"transactionId\": \"72oJ6qzBJw1ATGV6KTruFcPLEBeJ6yD4VwDhuEUU3Zu6\",\n  \"type\": \"TokenContractWithSplit\",\n  \"info\": [\n    {\n      \"data\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n      \"type\": \"Address\",\n      \"name\": \"issuer\"\n    },\n    {\n      \"data\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n      \"type\": \"Address\",\n      \"name\": \"maker\"\n    }\n  ],\n  \"height\": 301588\n}\n```\n\nWe can see that the contract we just created is of type TokenContract. The address we used to register the contract is both the <mark>issuer</mark> and the <mark>maker</mark> of this contract.\n\nA Token Contract can have only 1 kind of token. We can get the token ID by calling <mark>/contract/contractId/{contractId}/tokenIndex/0</mark>\n\nBelow is an example response body:\n\n```python:\n{\n    \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\"\n}\n```\n\nFill in the <mark>tok_id</mark> variable with it.\n\n```python:\n# The token id of the contract we just created\ntok_id = \"\" # <--- Fill in here\n```\n\nNow let’s check out the token defined in the contract. \n\nCall <mark>/contract/tokenInfo/{tokenId}</mark> and below is an example response body\n\n```python:\n{\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"contractId\": \"CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3\",\n  \"max\": 1000000000,\n  \"total\": 0,\n  \"unity\": 1,\n  \"description\": \"\"\n}\n```\n\nWe don’t have any tokens yet as indicated by the field <mark>\"total\"</mark> as we haven’t issued any. We would do so in the next step.\n\n\n### 3. Issue Tokens\n\nLet’s issue <mark>5000</mark> tokens. Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\n# Issue tokens\ntc.issue(\n    by=ACNT_0,\n    amount=5_000,\n)\n```\n\nRun it by <mark>python main.py</mark>\n\nWe can verify it by calling <mark>/contract/tokenInfo/{tokenId}</mark>. Below is an example response body.\n\n```python:\n{\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"contractId\": \"CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3\",\n  \"max\": 1000000000,\n  \"total\": 5000,\n  \"unity\": 1,\n  \"description\": \"\"\n}\n```\n\nGreat! we just issued <mark>5000</mark> tokens.\n\nYou may wonder who owns the tokens we just issued. Call <mark>/contract/balance/{address}/{tokenId}</mark> where the address is the address of the account we used to issue the tokens.\n\nThe address is a Base58 format string and is stored as the <mark>address</mark> attribute of <mark>pv.Account</mark> objects. For example, to print out the address of <mark>ACNT_0</mark>.\n\n```python:\nprint(ACNT_0.address)\n```\n\nBelow is an example response body.\n\n\n```python:\n{\n  \"address/contractId\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n  \"height\": 301675,\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"balance\": 5000,\n  \"unity\": 1\n}\n```\n\nAs you may have guessed, the freshly issued tokens belong to the issuer.\n\n\n### 4. Destroy Tokens\n\nSometimes you may want to destroy some tokens(e.g. to mitigate inflation). Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\ntc.destroy(\n    by=ACNT_0,\n    amount=2_000,\n)\n```\n\nRun it by <mark>python main.py</mark>\n\nLet’s now verify it by calling <mark>/contract/tokenInfo/{tokenId}</mark>. Below is an example response body.\n\n```python:\n{\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"contractId\": \"CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3\",\n  \"max\": 1000000000,\n  \"total\": 3000,\n  \"unity\": 1,\n  \"description\": \"\"\n}\n```\n\nThe total number of tokens has been reduced from <mark>5000</mark> to <mark>3000</mark>.\n\n\n### 5. Send Tokens\n\nIt does not make much sense if tokens are all kept to a single account. We can send tokens to another account. Comment out everything in the playground function try_token_contract() to leave only the snippet below.\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\ntc.send(\n    by=ACNT_0,\n    recipient=ACNT_1.address,\n    amount=500,\n)\n```\n\nRun it by <mark>python main.py</mark>\n\nLet’s verify if <mark>ACNT_1</mark> got the tokens by calling <mark>/contract/balance/{address}/{tokenId}</mark> respectively for <mark>ACNT_0</mark> & <mark>ACNT_1</mark>. Below are example response bodies.\n\n```python:\n{\n  \"address/contractId\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n  \"height\": 301778,\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"balance\": 2500,\n  \"unity\": 1\n}\n\n{\n  \"address/contractId\": \"AU5NsHE8eC2guo3JobD8jrGvnEDQhBP8GtW\",\n  \"height\": 301781,\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"balance\": 500,\n  \"unity\": 1\n}\n```\n\n### 6. Transfer Tokens\n\nYou may have noticed that there’s a quite similar function named <mark>transfer</mark>. It is the more powerful function actually used behind the scene in functions like send, deposit, and withdraw. \n\nLet’s send some tokens but with transfer this time.\n\nComment out everything in the playground function try_token_contract() to leave only the snippet below.\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\ntc.transfer(\n    by=ACNT_0,\n    sender=ACNT_0.address,\n    recipient=ACNT_1.address,\n    amount=300,\n)\n```\n\nRun it by <mark>python main.py</mark>\n\nLet’s verify if <mark>ACNT_1</mark> got the tokens by calling <mark>/contract/balance/{address}/{tokenId}</mark> respectively for <mark>ACNT_0</mark> & <mark>ACNT_1</mark>. Below are example response bodies.\n\n```python:\n{\n  \"address/contractId\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n  \"height\": 301795,\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"balance\": 2200,\n  \"unity\": 1\n}\n\n{\n  \"address/contractId\": \"AU5NsHE8eC2guo3JobD8jrGvnEDQhBP8GtW\",\n  \"height\": 301791,\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"balance\": 800,\n  \"unity\": 1\n}\n```\n\n### 7. Deposit Tokens to Another Contract\n\nFirst of all, we need to have a contract instance that can hold tokens and we will create an Atomic Swap Contract for it. \n\nComment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n```python:\ntok_id = \"your_token_id\"\n\nAtomicSwapContract.register(\n    by=ACNT_0,\n    token_id=tok_id,\n)\n```\n\nRun it by <mark>python main.py</mark>\n\nFind the <mark>contractId</mark> in the output and fill in the variable <mark>atomic_swap_contract_id</mark>.\n\n```python:\n# The contract id found in the output of registering the Atomic Swap Contract\natomic_swap_contract_id = \"\" # <--- Fill in here\n```\n\nWe can call the endpoint <mark>/contract/info/{contractId}</mark> to verify that the contract is created.\n\n```python:\n{\n  \"contractId\": \"CEz2xC1P1qxTm11Eq5Yj42d55VoRwaJP386\",\n  \"transactionId\": \"GeVejr5tbzS26WmK7Lq5wz9Q9kCMbYZ6iBQi6afpYfC6\",\n  \"type\": \"AtomicSwapContract\",\n  \"info\": [\n    {\n      \"data\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n      \"type\": \"Address\",\n      \"name\": \"maker\"\n    },\n    {\n      \"data\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n      \"type\": \"TokenId\",\n      \"name\": \"tokenId\"\n    }\n  ],\n  \"height\": 301809\n}\n```\n\nNow we can deposit some tokens into it.\n\nComment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\ntok_id = \"your_token_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\natomic_swap_contract_id = \"your_atomic_swap_contract_id\"\n\n# Now deposit to the atomic swap contract\ntc.deposit(\n    by=ACNT_0,\n    contract_id=atomic_swap_contract_id,\n    amount=300,\n)\n```\n\nRun it by <mark>python main.py</mark> and call <mark>/contract/balance/{address}/{tokenId}</mark> to verify the changes. Below is an example response body.\n\n\n```python:\n{\n  \"address/contractId\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n  \"height\": 301836,\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"balance\": 1900,\n  \"unity\": 1\n}\n```\n\nAs we can see, 300 tokens are deducted and our account has only 1900 tokens now.\n\nLet’s also check the balance of the Atomic Swap Contract by calling <mark>/contract/data/{contractId}/{key}</mark>. But before that, we need to generate the query key.\n\nComment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n```python:\nbal_key = pv_helper.AtomicSwapContractHelper().token_balance_db_key_generator(\n    address=ACNT_0.address,\n)\nprint(bal_key)\n```\n\nRun it by <mark>python main.py</mark> and call <mark>/contract/data/{contractId}/{key}</mark> with the key just generated. Note that the contractId here refers to the Atomic Swap Contract.\n\nBelow is an example response body.\n\n```python:\n{\n  \"contractId\": \"CEz2xC1P1qxTm11Eq5Yj42d55VoRwaJP386\",\n  \"key\": \"1Gqnifox5mNU9Ls3kKYnPuxf1jJ72fT5UhvWT\",\n  \"height\": 301863,\n  \"dbName\": \"contractNumInfo\",\n  \"value\": 300\n}\n```\n\nWe can see that our 300 tokens are deposited into the Atomic Swap Contract.\n\n\n### 8. Withdraw Tokens from Another Contract\n\nNow let’s try to withdraw tokens from the Atomic Swap Contract.\n\nComment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\natomic_swap_contract_id = \"your_atomic_swap_contract_id\"\n\ntc.withdraw(\n    by=ACNT_0,\n    contract_id=atomic_swap_contract_id,\n    amount=300,\n)\n```\nLet’s check the balance of the Atomic Swap Contract by calling <mark>/contract/data/{contractId}/{key}</mark> with the key generated earlier.\n\nBelow is an example response body.\n\n\n```python:\n{\n  \"contractId\": \"CEz2xC1P1qxTm11Eq5Yj42d55VoRwaJP386\",\n  \"key\": \"1Gqnifox5mNU9Ls3kKYnPuxf1jJ72fT5UhvWT\",\n  \"height\": 301883,\n  \"dbName\": \"contractNumInfo\",\n  \"value\": 0\n} \n```\n\nAs we can see, the balance has dropped back to 0.\n\nWe can also check if tokens are credited back to our account.\n\nCall <mark>/contract/balance/{address}/{tokenId}</mark> and below is an example response body.\n\n\n```python:\n{\n  \"address/contractId\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n  \"height\": 301887,\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"balance\": 2200,\n  \"unity\": 1\n}\n```\n300 tokens were credited back to our account and we have 2200 now.\n\n\n### 9. Split the Token\n\nSplitting the token actually means updating the unit. \n\nComment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\ntc.split(\n    by=ACNT_0,\n    new_unit=100,\n)\n```\n\nRun it by <mark>python main.py</mark> and call <mark>/contract/tokenInfo/{tokenId}</mark> to verify the change.\n\nBelow is an example response body\n\n```python:\n{\n  \"tokenId\": \"TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT\",\n  \"contractId\": \"CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3\",\n  \"max\": 1000000000,\n  \"total\": 3000,\n  \"unity\": 100,\n  \"description\": \"\"\n}\n```\nThe unit (as indicated by the field <mark>unity</mark>) has been updated from 1 to 100\n\n### 10. Transfer the Issuing Right to Another Account\n\nFinally, we can try to transfer the issuing right to another account with the <mark>supercede</mark> function.\n\nComment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.\n\n\n```python:\ntok_ctrt_id = \"your_token_contract_id\"\n\ntc = TokenContract(\n    contract_id=tok_ctrt_id,\n    split=True,\n)\n\ntc.supercede(\n    by=ACNT_0,\n    new_issuer=ACNT_1.address,\n)\n```\n\nRun it by <mark>python main.py</mark> and call <mark>/contract/info/{contractId}</mark> to verify the changes. Below is an example response body.\n\n\n```python:\n{\n  \"contractId\": \"CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3\",\n  \"transactionId\": \"72oJ6qzBJw1ATGV6KTruFcPLEBeJ6yD4VwDhuEUU3Zu6\",\n  \"type\": \"TokenContractWithSplit\",\n  \"info\": [\n    {\n      \"data\": \"AU5NsHE8eC2guo3JobD8jrGvnEDQhBP8GtW\",\n      \"type\": \"Address\",\n      \"name\": \"issuer\"\n    },\n    {\n      \"data\": \"AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD\",\n      \"type\": \"Address\",\n      \"name\": \"maker\"\n    }\n  ],\n  \"height\": 301588\n}\n```\n\nNow the issuer role is played by another account.\n\n\n## Troubleshooting\n\n### Didn't See Changes via APIs?\n\n- Ensure that you called the right API\n\n- Ensure the transaction is broadcast(i.e. no error in the response dictionary returned by SDK functions. For example, <mark>pv.Account.execute_contract</mark>) \n\n- Wait for 5s for the transaction to be fully on chain\n\n- Call <mark>/transactions/info/{id}</mark> to see if the transaction’s status is <mark>success</mark>"
    },
    "/get-started/smart-contracts/lock-contract": {
        "title": "Lock Contract",
        "text": "<!-- KEYWORDS: Lock Contract Smart Contract -->\n\n# Lock Contract\n\n## Introduction\n\nLock contracts allow users to lock a specific token in the contract for some period of time. This allows users to guarantee they have a certain amount of funds upon lock expiration. This may be helpful in implementing some kinds of staking interactions with users of a VSYS token for instance.\n\nThe lock contract is a very simple contract that is able to store a selected token. It allows anyone to execute this contract and lock their funds into it for some period of time. It is not necessary to open multiple lock contracts for different people to lock their coins of tokens.\n\n## Using the VSYS Python API Wrapper (pyvsystems)\n\nTo generate and broadcast transactions, we can use pyvsystems to test contract functionalities on the Vsys chain. \n\n### Install pyvsystems\n\nPyvsystems can be installed by first cloning the GitHub repository in terminal.\n\n```sh\ngit clone https://github.com/virtualeconomy/pyvsystems.git\n```\n\nThen using pip, we can install the repository as a package.\n\n```sh\npip3 install pyvsystems/.\n```\n\nNow you can import pyvsystems in your own workplace.\n\n## Register a lock contract\n\nBefore we start, please make sure you have already set up a mainnet node or a devnet node. For the devnet node set-up instruction, you can refer to “How to build your own V Systems Devnet“.\n\n### 1. To create and execute a lock contract of your own, you first need to initialize API connection.\n\n<b>Data required:</b>\n\n1. Your node address.\n2. Your api key(optional).\n3. Your seed.\n\n```python:\nimport pyvsystems as pv \nfrom pyvsystems import Account\nfrom pyvsystems.contract_helper import * \n\ncustom_wrapper = pv.create_api_wrapper(\"your_node_address\", api_key=\"your_node_api_key(optional)\") \n# chain = pv.Chain(chain_name='mainnet', chain_id='M', address_version=5, api_wrapper=custom_wrapper) # for mainnet \nchain = pv.Chain(chain_name='testnet', chain_id='T', address_version=5, api_wrapper=custom_wrapper) #for testnet or devnet\nsender = Account(chain=chain, seed=\"<your_sender_seed>\") \n```\n\n### 2. Next, we need to register the contract with contract_helper in pyvsystems. \n\n<b>Data required:</b>\n\n1.  Your token id. (you can create your own token in devnet for testing. For more information, please refer to “Token Contract”)\n\n```python:\nlock_contract_helper = LockContractHelper()\n\nlock_contract_object = lock_contract_helper.contract_object\n\nregister_lock_contract_data_stack = lock_contract_helper.register_data_stack_generator(\"your_token_id\")\n\nprint(\"register contract information: \",sender.register_contract(lock_contract_object, register_lock_contract_data_stack))\n\n```\n\nYou can see your contract information in the terminal. Take note of your contract id.\n\n## Using Lock Contract functions\n\nAfter registering the lock contract, you can execute the functions of the contract.\n\n| Executable functions | Function ID | Inputs        | Input types | Description                                |\n|:--------------------:|:-----------:|:-------------:|:-----------:|:------------------------------------------:|\n| lock()               | 0           | (“timestamp”) | long        | Lock the funds until a specified timestamp |\n\n### Lock Function:\n\n<b>Data required:</b>\n\n1. Lock contract’s id\n2. Lock timestamp\n\n```python:\n\nlock_contract_helper = LockContractHelper()\n\nlock_contract_id = \"your_lock_contract_id\"\n\nlock_function_id = lock_contract_helper.lock_function_index\n\nlock_data_stack = lock_contract_helper.lock_data_stack_generator(your_timestamp)\n\nsender.execute_contract(lock_contract_id, lock_function_id, lock_data_stack)\n\n```\n\n### Querying the Contract database\n\nIn order for the contract to do anything, it has to store some information within the database. This information can be queried by using the correct database key within the full node. The contract helper objects contain the corresponding database keys for each stored variable.\n\n### Get Lock Contract Maker\n\n<b>Data required:</b>\n\n1. Lock contract’s id\n\n```python:\nlock_contract_helper = LockContractHelper()\n\nlock_contract_id = \"<your_lock_contract_id>\"\n\nmaker_db_key = lock_contract_helper.maker_db_key_generator()\n\nprint(chain.contract_db_query(lock_contract_id, maker_db_key))\n```\n\n### Get Token id of the Supported Token\n\nThis helps you retrieve the token ID of the supported token in the lock contract.\n\n<b>Data required:</b>\n\n1. Lock contract’s id\n\n```python:\nlock_contract_helper = LockContractHelper()\n\nlock_contract_id = \"<your_lock_contract_id>\"\n\ntoken_id_db_key = lock_contract_helper.token_id_db_key_generator()\n\nprint(chain.contract_db_query(lock_contract_id, token_id_db_key))\n```\n\n### Get Address' Contract Balance\n\nThis helps you retrieve the Address' contract balance in the lock contract.\n\n<b>Data required:</b>\n\n1. Lock contract’s id\n\n```python:\nlock_contract_helper = LockContractHelper()\n\nlock_contract_id = \"<your_lock_contract_id>\"\n\ncontract_balance_db_key = lock_contract_helper.contract_balance_db_key_generator(sender.address)#sender is defined in initialize part\n\nprint(chain.contract_db_query(lock_contract_id, contract_balance_db_key))\n```\n\n###  Get Address' Lock Time\n\nThis helps you retrieve the lock time of the Address from the Lock Contract ID in the lock contract.\n\n<b>Data required:</b>\n\n1. Lock contract’s id\n\n```python:\nlock_contract_helper = LockContractHelper()\n\nlock_contract_id = \"<your_lock_contract_id>\"\n\ncontract_lock_time_db_key = lock_contract_helper.contract_lock_time_db_key_generator(sender.address)\n\nprint(chain.contract_db_query(lock_contract_id, contract_lock_time_db_key))\n```"
    },
    "/get-started/smart-contracts/nft-contract": {
        "title": "NFT Contract",
        "text": "<!-- KEYWORDS: Non-Fungible Token Smart Contract -->\n\n# NFT Contract\n\n## Introduction\n\nThe Non-fungible Token Contract acts as a method to create a single token that cannot be split into any parts. This gives a neat way of proving the ownership of some unique asset. A simple example is a token representing an item within a game, this token can then be sent from wallet to wallet, representing an in game trade.\n\n## Implementation\n\nThe Non-fungible contract controls a single token that can be sent, deposited or withdrawn. When registering a Non-fungible contract, it takes in no inputs. The token id of the issued token should be used to represent some form of unique asset, and the ownership of this token can easily be confirmed on the VSYS blockchain. It should be noted that the Non-fungible Token Contract can issue multiple tokens, each with its unique token id.\n\n\n## Register a Non-fungible Token Contract\n\n### Initialize API Connection\n\n```python:\nimport pyvsystems as pv\nfrom pyvsystems import Account\nfrom pyvsystems.contract import token_id_from_contract_id\nfrom pyvsystems.contract_helper import *\n\ncustom_wrapper = pv.create_api_wrapper(\"your_node_address\", api_key=\"your_node_api_key(optional)\")\n# chain = pv.Chain(chain_name='mainnet', chain_id='M', address_version=5, api_wrapper=custom_wrapper)\n\nchain = pv.Chain(chain_name='testnet', chain_id='T', address_version=5, api_wrapper=custom_wrapper)\n\nsender = Account(chain=chain, seed=\"your_sender_seed\")\n```\n\n### Non-fungible Token Contract ByteString:\n\n```python:\nVJodouhmnHVDwtkBZ2NdgahT7NAgNE9EpWoZApzobhpua2nDL9D3sbHSoRRk8bEFeme2BHrXPdcq5VNJcPdGMUD54Smwatyx74cPJyet6bCWmLciHE2jGw9u5TmatjdpFSjGKegh76GvJstK3VaLagvsJJMaaKM9MNXYtgJyDr1Zw7U9PXV7N9TQnSsqz6EHMgDvd8aTDqEG7bxxAotkAgeh4KHqnk6Ga117q5AJctJcbUtD99iUgPmJrC8vzX85TEXgHRY1psW7D6daeExfVVrEPHFHrU6XfhegKv9vRbJBGL861U4Qg6HWbWxbuitgtKoBazSp7VofDtrZebq2NSpZoXCAZC8DRiaysanAqyCJZf7jJ8NfXtWej8L9vg8PVs65MrEmK8toadcyCA2UGzg6pQKrMKQEUahruBiS7zuo62eWwJBxUD1fQ1RGPk9BbMDk9FQQxXu3thSJPnKktq3aJhD9GNFpvyEAaWigp5nfjgH5doVTQk1PgoxeXRAWQNPztjNvZWv6iD85CoZqfCWdJbAXPrWvYW5FsRLW1xJ4ELRUfReMAjCGYuFWdA3CZyefpiDEWqVTe5SA6J6XeUppRyXKpKQTc6upesoAGZZ2NtFDryq22izC6D5p1i98YpC6Dk1qcKevaANKHH8TfFoQT717nrQEY2aLoWrA1ip2t5etdZjNVFmghxXEeCAGy3NcLDFHmAfcBZhHKeJHp8H8HbiMRtWe3wmwKX6mPx16ahnd3dMGCsxAZfjQcy4J1HpuCm7rHMULkixUFYRYqx85c7UpLcijLRybE1MLRjEZ5SEYtazNuiZBwq1KUcNipzrxta9Rpvt2j4WyMadxPf5r9YeAaJJp42PiC6SGfyjHjRQN4K3pohdQRbbG4HQ95NaWCy7CAwbpXRCh9NDMMQ2cmTfB3KFW2M\n```\n\n### Code:\n```python:\non_fungible_contract_helper = NonFungibleContractHelper()\n\nnon_fungible_contract_object = non_fungible_contract_helper.contract_object\n\nregister_non_fungible_data_stack = non_fungible_contract_helper.register_data_stack_generator()\n\nsender.register_contract(non_fungible_contract_object, register_non_fungible_data_stack)\n\n```"
    },
    "/get-started/smart-contracts/payment-contract": { "title": "Payment Contract" },
    "/get-started/smart-contracts/v-swap": { "title": "V Swap Contract" },
    "/get-started/smart-contracts/v-atomic-swap": {
        "title": "V Atomic Swap Contract",
        "text": "<!-- KEYWORDS: Atomic Swap Contract -->\n\n# V Atomic Swap Contract\n\n## introduction\n\nThe Atomic Swap is a method of swapping coins or tokens in a secure manner that requires no trusted party to hold custody of the coins. When swapping coins, the two untrusted party runs into a problem, whoever gets sent the coins first can simply abandon the deal and run off with the coins.\n\nThe Atomic Swap solves this issue by using the properties of a hash function, that the hash function is deterministic (the same input gives the same output), and that it cannot be reversed (the input cannot be determined from the output).\n\n\n## Example\n\nYou will understand what atomic swap contract does in v.systems with the following example.\n\nLet’s take Alice and Bob as an example. Alice wants to exchange 1 BTC for 3 ETH with Bob. For safety reasons, they use the atomic swap contract.\n\nFirst, Alice will create a secret A and hash it, get Hash(secret A). Since hash value is infeasible to reverse, no one should be able to get Secret A from Hash(Secret A).\n\nAlice then creates an Atomic swap contract Contract A, and then deposit 1 BTC into the contract. There will be two different situations:\n\n1. If Alice broadcasts secret A before timestamp B, Contract A will transfer 1 BTC to Bob’s address.\n\n2. If nothing is done before timestamp A, 1 BTC will return to Alice’s address.\n\nThen Bob creates an Atomic Swap contract Contract B and then deposit 3 ETH into the contract. There will be two different situations:\n\n1. If Alice has broadcasted secret A before timestamp B, Contract B can get secret A to transfer 3 ETH to Alice’s address.\n\n2. If nothing is done before timestamp B, 3 ETH will return to Bob’s address.\n\nRemember that timestamp B must be earlier than timestamp A, otherwise, Alice may withdraw 1 BTC and receive Bob’s 3 ETH.\n\n\n## Implementation\n\nThe VSYS Atomic Swap contract can store a single type of Token. To swap between different Tokens, two separate contracts are necessary. Users are required to deposit Tokens into the contract before they are able to lock it.\n\nThe **lock** function itself is fairly simplistic, the input should be the hash of some secret together with the determined recipient and an expiration timestamp. To unlock the lock, the recipient simply needs to call the **SolvePuzzle** function with the transaction id of the lock together with the secret.\n\nThe contract will check that the hash of the secret matches the puzzle in the lock. If it matches, the contract will transfer ownership of the locked coins or tokens to the recipient. Note, however, that while the funds change ownership, they stay within the contract, so the wallet's balance won't change until the recipient withdraws the funds from the contract.\n\n\n## Using the VSYS Python API Wrappers pyvsystems\n\nTo generate and broadcast transactions, we can use pyvsystems to test contract functionalities on the VSYS chain.\n\n### Install pyvsystems\n\n**pyvsystems** can be installed by first cloning the github repository.\n\n```python:\ngit clone https://github.com/virtualeconomy/pyvsystems.git\n```\n\nThen using pip, we can install the repository as a package.\n\n```python:\npip3 install pyvsystems/.\n```\n\nNow you can import pyvsystems in your own workplace.\n\nregister an atomic swap contract\n\n\n### Initialize the API Connection\n\n**Data Required:**\n\n1. Node host\n2. Api key\n3. Seeds for two account\n\n\n```python:\nimport pyvsystems as pv\nfrom pyvsystems import Account\nfrom pyvsystems.contract import token_id_from_contract_id, data_entry_from_base58_str\nfrom pyvsystems.crypto import sha256\nfrom pyvsystems.contract_helper import *\n\ncustom_wrapper = pv.create_api_wrapper('<your_node_ip>', api_key='<your_node_api_key>')\nchain = pv.Chain(chain_name='mainnet', chain_id='M', address_version=5, api_wrapper=custom_wrapper)\nsender1 = Account(chain=chain, seed='<your_account1_seed>', nonce=0)\nsender2 = Account(chain=chain, seed='<your_account2_seed>', nonce=0)\n```\n\n\n### Register Swap Contracts\n\nEach swap contract can only store one type of token or coin, and needs to be determined when the contracts are registered.\n\n**Data Required:**\n\n1. Two token ids.\n\n```python:\n# Register a swap contract that stores the two respective tokens\n# Note that sender1 owns token1, while sender2 owns token2\natomic_swap_helper = AtomicSwapContractHelper()\nsystem_helper = SystemContractHelper()\nswap_contract = Contract(Contract_Atomic_Swap)\n\ntoken1_id_data_entry = DataEntry(token1_id, Type.token_id)\ninit_swap1_data_stack = [token1_id_data_entry]\nregister_swap1_response = sender1.register_contract(swap_contract, init_swap1_data_stack)\n\ntoken2_id_data_entry = DataEntry(token2_id, Type.token_id)\ninit_swap2_data_stack = [token2_id_data_entry]\nregister_swap2_response = sender2.register_contract(swap_contract, init_swap2_data_stack)\n```\n\n### Deposit into Swap Contracts\n\nContracts can only interact with tokens or coins deposited into them, therefore before the tokens can be locked and swapped, they must be deposited into the Swap Contracts.\n\n**Data Required:**\n\n1. Two sender's addresses.\n2. Two Swap contracts' id.\n3. The amount you want to deposit into 2 contracts.\n4. Two token contracts' id.\n\n\n```python:\n# After registering the two swap contracts, we can deposit into them\n# using their contract ids\n\ndeposit1_data_stack = token_without_split_helper.deposit_data_stack_generator(sender1.address, swap1_contract_id, deposit_amount)\ndeposit2_data_stack = token_without_split_helper.deposit_data_stack_generator(sender2.address, swap2_contract_id, 1000)\n\nsender1.execute_contract(token1_contract_id, token_without_split_helper.deposit_function_index, deposit1_data_stack)\nsender2.execute_contract(token2_contract_id, token_without_split_helper.deposit_function_index, deposit2_data_stack)\n```\n\n\n### Lock the Deposited Funds\n\nThe transaction that locks the funds are public on the blockchain, so it is simple to observe the resulting hash of the secret. Ensure that both locks use the same hash so that when the first lock is unlocked, the secret is revealed.\n\n**Data Required:**\n\n1. Your Secret(like \"abc\")\n2. Swap Amount for Both\n3. sender1 and sender2’s addresses\n4. Timestamp1\n5. Swap Contacts' id.\n\n\n```python:\n# After depositing both tokens into their respective swap contracts\n# we can lock them both, ensuring that the second timestamp is lower than the first\n\n# First decide on a secret, hash and encode it\n\nsecret = \"abc\"\nencoded_secret_hash_string = bytes2str(base58.b58encode(sha256(secret)))\n\nlock1_data_stack = atomic_swap_helper.lock_data_stack_generator(lock_amount, sender2.address, encoded_secret_hash_string, timestamp1)\n#execute print the tx id\nprint(sender1.execute_contract(swap1_contract_id, atomic_swap_helper.lock_function_index, lock1_data_stack))\n\n# Lock id is the tx id of the lock transaction\nlock1_id = \"tx_id_of_lock\"\n\n# Sender2 would be able to find the hash string by decoding the lock transaction data\n\nlock1_function_data = chain.contract_db_query(swap1_contract_id, atomic_swap_helper.swap_puzzle_db_key_generator(lock1_id))\n\ntx_data_encoded_secret_hash_string = data_entry_from_base58_str(lock1_function_data['value'])\n\nswap2_amount_data_entry = DataEntry(amount_for_swap2, Type.amount)\nswap2_recipient_data_entry = DataEntry(sender1.address, Type.address)\nswap2_puzzle_data_entry = DataEntry(tx_data_encoded_secret_hash_string, Type.short_bytes_string)\nswap2_timestamp_data_entry = DataEntry(timestamp2, Type.timestamp)\n\nswap2_lock_data_stack = [swap2_amount_data_entry, swap2_recipient_data_entry, swap2_puzzle_data_entry, swap2_timestamp_data_entry]\n\nlock2_response = sender2.execute_contract(swap2_contract_id, 0, swap2_lock_data_stack)\nlock2_tx_id = lock2_response['id']\n```\n\n\n### Solve the Puzzles\n\nSolving both puzzles will complete the swap. Once the first puzzle is solved the secret is revealed to the entire blockchain and can be found using the transaction's functionData. Sender2 will be able to decode this data and unlock the first lock.\n\n**Data Required:**\n\n1. Your Secret(like \"abc\")\n2. lock1/2 tx id\n3. swap contracts' id\n\n\n```python:\n# Once we properly lock the funds, sender1 will first solve the lock\n\nswap1_lock_txid_data_entry = DataEntry(lock2_tx_id, Type.short_bytes_string)\nswap1_lock_key_data_entry = DataEntry(\"abc\", Type.short_bytes)\n\nswap1_solve_data_stack = [swap1_lock_tx_id_data_entry, swap1_lock_key_data_entry]\n\nsolve1_response = sender1.execute_contract(swap2_contract_id, 1, swap1_solve_data_stack)\n\n# Sender2 can then look at the function data to find the solution\n# This transaction id can be found by looking at the transactions of sender1 for example.\n\nsolve1_function_data = chain.api_wrapper.request('transactions/info/%s'%(solve1_response['id']))['functionData']\n\nsolve_key = bytes2str(base58.b58decode(data_entry_from_base58_str(solve1_function_data)[1].data))\n\n# The chain stores the input data as a base58 encoded string of the bytes.\n# The inputs to contracts are always data entries, so it is simple to parse the data into data entries.\n# The input is also base58 encoded, so we will have to base58 decode the final value.\n\nrevealed_secret = base58.b58decode(data_entry_from_base58_str(solve1_function_data['value']))\n\nsolve_puzzle2_data_stack = atomic_swap_helper.solve_puzzle_data_stack_generator(lock1_tx_id, base58.b58encode(revealed_secret))\n\nsender2.execute_contract(swap1_contract_id, atomic_swap_helper.solve_puzzle_function_index, solve_puzzle2_data_stack)\n\n```\n\n### Withdraws the Funds\n\nOnce the puzzle is solved, the ownership of the tokens has changed, however, the funds remain in the contract until they are withdrawn.\n\n**Data Required:**\n\n1. swap contracts' id.\n2. senders' addresses.\n3. token contracts' id.\n\n\n```python:\n# After transferring ownership of tokens, we can withdraw them\n\nwithdraw1_data_stack = token_without_split_helper.withdraw_data_stack_generator(swap2_contract_id, sender1.address, 1000)\n\nwithdraw2_data_stack = token_without_split_helper.withdraw_data_stack_generator(swap1_contract_id, sender2.address, 1000)\n\nsender1.execute_contract(token2_contract_id, token_without_split_helper.withdraw_function_index, withdraw1_data_stack)\n\nsender2.execute_contract(token1_contract_id, token_without_split_helper.withdraw_function_index, withdraw2_data_stack)\n```\n"
    },
    "/get-started/smart-contracts/v-stable-swap": {
        "title": "V Stable Swap Contract",
        "text": "<!-- KEYWORDS: V Stable Swap Smart Contract -->\n\n# V Stable Swap Contract\n\n## Introduction\n\nV Stable Swap Contract documentation coming soon.\n\n"
    },
    "/get-started/smart-contracts/v-option": {
        "title": "V Option Contract",
        "text": "<!-- KEYWORDS: V Option Smart Contract -->\n\n# V Option Contract\n\n## Introduction\n\nV Option Contract coming soon."
    },
    "/get-started/smart-contracts/v-escrow": {
        "title": "V Escrow Contract",
        "text": "<!-- KEYWORDS: V Escrow Smart Contract -->\n\n# V Escrow Contract\n\n## Introduction\n\nV Option Contract coming soon."
    },
    "/development/environment": {
        "title": "Environment Setup",
        "text": "import { Divider } from '../../app/components';\n\n<!-- KEYWORDS: developer develop environment guide tutorial -->\n\n# Setting up Your Development Environment\n\nGetting started is often the most frustrating part of application development. Fortunately, many of the modern JavaScript frameworks have made great strides in providing tools to get you up and running as quickly as possible. Below, we walk through the basics of getting your system set up to develop.\n\n## Integrated Development Environment (IDE)\n\nThere are a bunch of different IDEs on the market, and in general you should be able to use any of these that you like and are comfortable with. If you don't have a personal preference, we recommend trying [Visual Studio Code](https://code.visualstudio.com) - it is quite excellent and comes with a variety of tools to make your development experience seamless. And it's free!\n\n## Git\n\nChances are, you probably want to keep your application in source control. Git is one of the big players in this space (it's also the backbone for BitBucket).\n\nYou may already have git installed. To check, run:\n\n```sh\ngit --version\n```\n\nin a command prompt. If you don't have git installed, you can download it from the [Git Website](http://git-scm.com/downloads).\n\nIf you are behind a proxy, you'll also need to set up the git proxies as well:\n\n```sh\ngit config --global http.proxy http://url.to.your.proxy:port\ngit config --global https.proxy http://url.to.your.proxy:port\n```\n\nThe proxy addresses may vary depending on your location. Consult your local IT department if you’re not sure.\n\n## Node\n\nThe majority of JavaScript frameworks (and Brightlayer UI resources) are available via the Node Package Manager (NPM). This package manager allows you to install a variety of third party tools, packages, and other dependencies that you need for your applications. To use NPM, you will need to install [NodeJS](https://nodejs.org/en/download/).\n\n## Yarn\n\nOur projects and example code are set up to be run using yarn, but if you prefer, you're welcome to use NPM in your projects instead. Instructions for installing yarn on various operating systems can be found on the [Yarn Website](https://yarnpkg.com/en/docs/install).\n\nTo check if you have yarn installed, run:\n\n```sh\nyarn -v\n```\n\nfrom a command prompt. If you are behind a proxy, you will also need to configure your proxy settings. It may be sufficient for you to set `HTTP_PROXY` and `HTTPS_PROXY` in your environment variables. However, you may need to also explicitly set proxy values for yarn:\n\n```sh\nyarn config set proxy http://url.to.your.proxy:port\nyarn config set https-proxy http://url.to.your.proxy:port\n```\n\nThe proxy addresses may vary depending on your location. Consult your local IT department if you’re not sure. Once you have configured the proxy, you should be able to install packages by using:\n\n```sh\nyarn add <package-name>\n```\n\n> If you are installing packages globally using yarn, you will need to ensure that your PATH variable has an entry pointing to your global yarn install directory. This location will vary based on your operating system.\n\n<Divider />\n\n# Hybrid App Development\n\nIf you are setting up for building a mobile app, there are some additional steps you will want to take to prepare. The following requirements are the basics. Depending on your selected [framework](/development/frameworks-mobile/intro), there will be other specific setup steps detailed in our Getting Started Guides.\n\n## Prerequisites\n\n### Hardware\n\nMobile development is resource-intensive, so you will need a development machine that is up to the task. Your machine should at least match the following minimum requirements:\n\n-   a Mac (if you plan on building or testing iOS locally)\n-   16GB RAM or more (running multiple emulators can easily push you over 20GB)\n-   Solid State Hard Drive (SSD)\n-   5/6 Gen Core i7 with Virtualization Technology or better\n\n### Software\n\nThere are a few software tools that you will need before you can get started:\n\n<!-- markdown-link-check-disable -->\n\n-   [Android Studio](https://developer.android.com/studio/) (required for building for Android)\n    <!-- markdown-link-check-enable -->\n-   [xCode](https://developer.apple.com/xcode/) (Mac-only, required for building for iOS)\n"
    },
    "/development/testing": {
        "title": "Testing",
        "text": "import { DemoCard, ImageGrid, MaterialDesignDescription, Divider } from '../../app/components';\n\n# Testing Your V Systems Applications\n\n<!-- KEYWORDS: testing test unit e2e tdd bdd integration cypress -->\n\n## V Explorer - Transaction Explorer\n\nExplore transactions and network activity on our [V Systems Explorer](https://explorer.v.systems/).\n\n"
    },
    "/resources/developer": { "title": "Developer Resources" }
}
