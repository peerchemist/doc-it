<!-- KEYWORDS: Token Contract Smart Contract -->

# Token Contract Introduction

A **Token Contract** allows users to set up their own tokens on an existing blockchain (e.g. the VSYS chain in our case).

A token is a logical entity on the blockchain. It can represent basically everything that can be stored in a database. Be it a fiat currency like USD, financial assets like a share in a company, or even reputation points of an online platform.

A contract can be thought of as a class in OOP with a bunch of methods. After creating an instance of a contract, functions can be called by sending the function index and arguments(A.K.A Data Stack) to the contract instance.



> If you are new to blockchain, it is highly recommended to quickly go through resources in External Resources of Topics in Blockchain to equip yourself with fundamental knowledge before going further.



There are two types of tokens, namely token <mark>with split</mark> and token <mark>without split</mark> in VSYS. The key difference is **if a token can be further broken down into smaller pieces (and vice versa)**. For example, Bitcoin is token with spilt as it is possible to buy 0.1 Bitcoin while a song is token without split as it makes no sense to buy half a song.

Note that **one instance of Token Contract can define only ONE kind of token for now** though theoretically, it is possible to have multiple kinds of tokens within a contract.


## Available Functions for Token Contract

| Executable functions 	| Function ID for Token without Split 	| Function ID for Token with Split 	|             Input types             	|             Input Types             	|                          Description                          	| Available Only to the Address with the Issuing Right 	|
|:--------------------:	|:-----------------------------------:	|:--------------------------------:	|:-----------------------------------:	|:-----------------------------------:	|:-------------------------------------------------------------:	|:----------------------------------------------------:	|
|      TotalSupply     	|                  7                  	|                 8                	|                  ()                 	|                  ()                 	|                       Currently not used                      	|                                                      	|
|       MaxSupply      	|                  8                  	|                 9                	|                  ()                 	|                  ()                 	|                       Currently not used                      	|                                                      	|
|       GetIssuer      	|                  10                 	|                11                	|                  ()                 	|                  ()                 	|                       Currently not used                      	|                                                      	|
|       Supersede      	|                  0                  	|                 0                	|            ("newIssuer")            	|              (address)              	| Transfer the issuing right of the contract to another account 	|                                                      	|
|       BalanceOf      	|                  9                  	|                20                	|             ("address")             	|              (address)              	|                       Currently not used                      	|                                                      	|
|         Send         	|                  3                  	|                 4                	|       ("recipient", "amount")       	|          (address, amount)          	|                          Send tokens                          	|                                                      	|
|       Transfer       	|                  4                  	|                 5                	|  ("sender", "recipient", "amount")  	|      (address, address, amount)     	|            Transfer tokens from sender to recipient           	|                                                      	|
|        Deposit       	|                  5                  	|                 6                	|   ("sender", "contract", "amount")  	| (address, contract_account, amount) 	|              Deposit tokens into another contract             	|                                                      	|
|         Issue        	|                  1                  	|                 1                	|              ("amount")             	|               (amount)              	|                        Issue new tokens                       	|                          Yes                         	|
|        Destroy       	|                  2                  	|                 2                	|              ("amount")             	|               (amount)              	|                         Destroy tokens                        	|                          Yes                         	|
|         Split        	|                 N/A                 	|                 3                	|             ("newUnit")             	|               (amount)              	|                        Update the unit                        	|                          Yes                         	|
|       Withdraw       	|                  6                  	|                 7                	| ("contract", "recipient", "amount") 	| (contract_account, address, amount) 	|             Withdraw tokens from another contract             	|                                                      	|


## FAQ

### What is "Unit"?

“Unit” is the granularity of splitting a token. It can be thought of as the smallest denomination available. Let’s take real-world money as an example, if the unit is set to 100, it means the smallest denomination is a cent, and 100 cents is a dollar.

**“Unit” exists to use only integers to represent splitted tokens(e.g. 0.1) as float computation is uncertainty-prone**. If we set unit == 100, 1.5 tokens are actually stored as 150 in the blockchain.


### Difference between the function "Send" & "Transfer"?

**Transfer** is the most powerful function as it allows customising the sender & the recipient at the same time. 

> For contract functions, the contract instance would verify the invoker as per its pre-defined whitelist. Actions defined in the function would be taken only if the invoker is proved valid.

Function <mark>Send</mark>, <mark>Deposit</mark>, and <mark>Withdraw</mark> can be considered as special cases of <mark>Transfer</mark> and is built on top ofTransfer.

<mark>Send</mark>: The sender is set to the invoker itself. The recipient has to be an account.

<mark>Deposit</mark>: The sender has to be the invoker itself. The recipient has to be a contract

<mark>Withdraw</mark>: The sender has to be a contract. The recipient has to be the invoker itself.

Calling <mark>Transfer</mark> with the sender and the recipient both set to a contract is NOT supported yet but theoretically possible.

> It is discouraged to call function <mark>Transfer</mark> directly in application codes. Call more specialised function like <mark>Send</mark>, <mark>Deposit</mark>, <mark>Withdraw</mark> instead.


## Tutorial

In this tutorial, we are going to create a new Token Contract with **splittable** tokens and play around with it. Token Contract with **unsplittable** tokens is basically the same except that it does not have the split function.

This tutorial is built upon the [Python SDK](https://github.com/virtualeconomy/pyvsystems) of V Systems Github.

### 0. Pre-Requisites

    Ensure that you have:

    1. Tried out the Swagger interactive API doc for RESTful APIs of the Testnet. It is a user-friendly tool to query the status and verify the changes on the chain

    2. Gone through the tutorial of building your own VSYS dev net and have your Testnet wallet seed available after it

    3. Topped up sufficient VSYS coins to the devnet(http://veldidina.vos.systems:9928/) as the gas fee for the tutorial. Gas fee for some operations:

        - Create a contract: 100 VSYS

        - Execute a contract function: 0.3 VSYS

    4. Installed Python 3.7+

    5. installed pipenv via which we will install the Python SDK of V Systems



### 1. Get the Example Codes &amp; Set Up Environment

 Clone the repository of example codes

```python:
git clone git@github.com:virtualeconomy/py-v-sdk-examples.git
```


Go to the root directory of the repo and install dependencies
```python:
pipenv install
```

Fill in your Testnet wallet seed in main.py

```python:
NODE_HOST = "http://veldidina.vos.systems:9928" # The testnet
WALLET_SEED = "" # <--- Fill in your testnet wallet seed here
```

Leave only the playground function try_token_contract() in the main function and comment out other playground functions.

```python:
def main():
    try_token_contract()
    # try_atomic_swap_contract()
```

> Statements for common operations are provided in the playground function <mark>try_token_contract</mark> and can be commented out on demand when playing around.


### 2. Register a Token Contract

Comment out everything in the playground function try_token_contract() to leave only the snippet below.


```python:
# Register a Token Contract with splittable tokens
# Note that it registers a new Token Contract every time it runs
tc = TokenContract.register(
    by=ACNT_0,
    max=1_000_000_000,
    unit=1,
    split=True,
)
```

Run it by <mark>python main.py</mark>

A Python dictionary will be printed to the console. Find the contractId in it and fill it to the variable <mark>tok_ctrt_id</mark>

```python:
# The contract id found in the output of registering the Token Contract
tok_ctrt_id = " " # <--- Fill in here
```

We can call the endpoint <mark>/contract/info/{contractId}</mark> to verify that the contract is created through the [Swagger interactive API doc for RESTful APIs of the Testnet](http://veldidina.vos.systems:9928/api-docs/index.html)

Below is an example response body:

```python:
{
  "contractId": "CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3",
  "transactionId": "72oJ6qzBJw1ATGV6KTruFcPLEBeJ6yD4VwDhuEUU3Zu6",
  "type": "TokenContractWithSplit",
  "info": [
    {
      "data": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
      "type": "Address",
      "name": "issuer"
    },
    {
      "data": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
      "type": "Address",
      "name": "maker"
    }
  ],
  "height": 301588
}
```

We can see that the contract we just created is of type TokenContract. The address we used to register the contract is both the <mark>issuer</mark> and the <mark>maker</mark> of this contract.

A Token Contract can have only 1 kind of token. We can get the token ID by calling <mark>/contract/contractId/{contractId}/tokenIndex/0</mark>

Below is an example response body:

```python:
{
    "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT"
}
```

Fill in the <mark>tok_id</mark> variable with it.

```python:
# The token id of the contract we just created
tok_id = "" # <--- Fill in here
```

Now let’s check out the token defined in the contract. 

Call <mark>/contract/tokenInfo/{tokenId}</mark> and below is an example response body

```python:
{
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "contractId": "CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3",
  "max": 1000000000,
  "total": 0,
  "unity": 1,
  "description": ""
}
```

We don’t have any tokens yet as indicated by the field <mark>"total"</mark> as we haven’t issued any. We would do so in the next step.


### 3. Issue Tokens

Let’s issue <mark>5000</mark> tokens. Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.

```python:
tok_ctrt_id = "your_token_contract_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

# Issue tokens
tc.issue(
    by=ACNT_0,
    amount=5_000,
)
```

Run it by <mark>python main.py</mark>

We can verify it by calling <mark>/contract/tokenInfo/{tokenId}</mark>. Below is an example response body.

```python:
{
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "contractId": "CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3",
  "max": 1000000000,
  "total": 5000,
  "unity": 1,
  "description": ""
}
```

Great! we just issued <mark>5000</mark> tokens.

You may wonder who owns the tokens we just issued. Call <mark>/contract/balance/{address}/{tokenId}</mark> where the address is the address of the account we used to issue the tokens.

The address is a Base58 format string and is stored as the <mark>address</mark> attribute of <mark>pv.Account</mark> objects. For example, to print out the address of <mark>ACNT_0</mark>.

```python:
print(ACNT_0.address)
```

Below is an example response body.


```python:
{
  "address/contractId": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
  "height": 301675,
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "balance": 5000,
  "unity": 1
}
```

As you may have guessed, the freshly issued tokens belong to the issuer.


### 4. Destroy Tokens

Sometimes you may want to destroy some tokens(e.g. to mitigate inflation). Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.

```python:
tok_ctrt_id = "your_token_contract_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

tc.destroy(
    by=ACNT_0,
    amount=2_000,
)
```

Run it by <mark>python main.py</mark>

Let’s now verify it by calling <mark>/contract/tokenInfo/{tokenId}</mark>. Below is an example response body.

```python:
{
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "contractId": "CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3",
  "max": 1000000000,
  "total": 3000,
  "unity": 1,
  "description": ""
}
```

The total number of tokens has been reduced from <mark>5000</mark> to <mark>3000</mark>.


### 5. Send Tokens

It does not make much sense if tokens are all kept to a single account. We can send tokens to another account. Comment out everything in the playground function try_token_contract() to leave only the snippet below.

```python:
tok_ctrt_id = "your_token_contract_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

tc.send(
    by=ACNT_0,
    recipient=ACNT_1.address,
    amount=500,
)
```

Run it by <mark>python main.py</mark>

Let’s verify if <mark>ACNT_1</mark> got the tokens by calling <mark>/contract/balance/{address}/{tokenId}</mark> respectively for <mark>ACNT_0</mark> & <mark>ACNT_1</mark>. Below are example response bodies.

```python:
{
  "address/contractId": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
  "height": 301778,
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "balance": 2500,
  "unity": 1
}

{
  "address/contractId": "AU5NsHE8eC2guo3JobD8jrGvnEDQhBP8GtW",
  "height": 301781,
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "balance": 500,
  "unity": 1
}
```

### 6. Transfer Tokens

You may have noticed that there’s a quite similar function named <mark>transfer</mark>. It is the more powerful function actually used behind the scene in functions like send, deposit, and withdraw. 

Let’s send some tokens but with transfer this time.

Comment out everything in the playground function try_token_contract() to leave only the snippet below.

```python:
tok_ctrt_id = "your_token_contract_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

tc.transfer(
    by=ACNT_0,
    sender=ACNT_0.address,
    recipient=ACNT_1.address,
    amount=300,
)
```

Run it by <mark>python main.py</mark>

Let’s verify if <mark>ACNT_1</mark> got the tokens by calling <mark>/contract/balance/{address}/{tokenId}</mark> respectively for <mark>ACNT_0</mark> & <mark>ACNT_1</mark>. Below are example response bodies.

```python:
{
  "address/contractId": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
  "height": 301795,
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "balance": 2200,
  "unity": 1
}

{
  "address/contractId": "AU5NsHE8eC2guo3JobD8jrGvnEDQhBP8GtW",
  "height": 301791,
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "balance": 800,
  "unity": 1
}
```

### 7. Deposit Tokens to Another Contract

First of all, we need to have a contract instance that can hold tokens and we will create an Atomic Swap Contract for it. 

Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.

```python:
tok_id = "your_token_id"

AtomicSwapContract.register(
    by=ACNT_0,
    token_id=tok_id,
)
```

Run it by <mark>python main.py</mark>

Find the <mark>contractId</mark> in the output and fill in the variable <mark>atomic_swap_contract_id</mark>.

```python:
# The contract id found in the output of registering the Atomic Swap Contract
atomic_swap_contract_id = "" # <--- Fill in here
```

We can call the endpoint <mark>/contract/info/{contractId}</mark> to verify that the contract is created.

```python:
{
  "contractId": "CEz2xC1P1qxTm11Eq5Yj42d55VoRwaJP386",
  "transactionId": "GeVejr5tbzS26WmK7Lq5wz9Q9kCMbYZ6iBQi6afpYfC6",
  "type": "AtomicSwapContract",
  "info": [
    {
      "data": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
      "type": "Address",
      "name": "maker"
    },
    {
      "data": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
      "type": "TokenId",
      "name": "tokenId"
    }
  ],
  "height": 301809
}
```

Now we can deposit some tokens into it.

Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.

```python:
tok_ctrt_id = "your_token_contract_id"
tok_id = "your_token_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

atomic_swap_contract_id = "your_atomic_swap_contract_id"

# Now deposit to the atomic swap contract
tc.deposit(
    by=ACNT_0,
    contract_id=atomic_swap_contract_id,
    amount=300,
)
```

Run it by <mark>python main.py</mark> and call <mark>/contract/balance/{address}/{tokenId}</mark> to verify the changes. Below is an example response body.


```python:
{
  "address/contractId": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
  "height": 301836,
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "balance": 1900,
  "unity": 1
}
```

As we can see, 300 tokens are deducted and our account has only 1900 tokens now.

Let’s also check the balance of the Atomic Swap Contract by calling <mark>/contract/data/{contractId}/{key}</mark>. But before that, we need to generate the query key.

Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.

```python:
bal_key = pv_helper.AtomicSwapContractHelper().token_balance_db_key_generator(
    address=ACNT_0.address,
)
print(bal_key)
```

Run it by <mark>python main.py</mark> and call <mark>/contract/data/{contractId}/{key}</mark> with the key just generated. Note that the contractId here refers to the Atomic Swap Contract.

Below is an example response body.

```python:
{
  "contractId": "CEz2xC1P1qxTm11Eq5Yj42d55VoRwaJP386",
  "key": "1Gqnifox5mNU9Ls3kKYnPuxf1jJ72fT5UhvWT",
  "height": 301863,
  "dbName": "contractNumInfo",
  "value": 300
}
```

We can see that our 300 tokens are deposited into the Atomic Swap Contract.


### 8. Withdraw Tokens from Another Contract

Now let’s try to withdraw tokens from the Atomic Swap Contract.

Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.


```python:
tok_ctrt_id = "your_token_contract_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

atomic_swap_contract_id = "your_atomic_swap_contract_id"

tc.withdraw(
    by=ACNT_0,
    contract_id=atomic_swap_contract_id,
    amount=300,
)
```
Let’s check the balance of the Atomic Swap Contract by calling <mark>/contract/data/{contractId}/{key}</mark> with the key generated earlier.

Below is an example response body.


```python:
{
  "contractId": "CEz2xC1P1qxTm11Eq5Yj42d55VoRwaJP386",
  "key": "1Gqnifox5mNU9Ls3kKYnPuxf1jJ72fT5UhvWT",
  "height": 301883,
  "dbName": "contractNumInfo",
  "value": 0
} 
```

As we can see, the balance has dropped back to 0.

We can also check if tokens are credited back to our account.

Call <mark>/contract/balance/{address}/{tokenId}</mark> and below is an example response body.


```python:
{
  "address/contractId": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
  "height": 301887,
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "balance": 2200,
  "unity": 1
}
```
300 tokens were credited back to our account and we have 2200 now.


### 9. Split the Token

Splitting the token actually means updating the unit. 

Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.

```python:
tok_ctrt_id = "your_token_contract_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

tc.split(
    by=ACNT_0,
    new_unit=100,
)
```

Run it by <mark>python main.py</mark> and call <mark>/contract/tokenInfo/{tokenId}</mark> to verify the change.

Below is an example response body

```python:
{
  "tokenId": "TWteznkp33Ttrmb6CJPeb5fWU4LH4zqJFMEbJMeQT",
  "contractId": "CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3",
  "max": 1000000000,
  "total": 3000,
  "unity": 100,
  "description": ""
}
```
The unit (as indicated by the field <mark>unity</mark>) has been updated from 1 to 100

### 10. Transfer the Issuing Right to Another Account

Finally, we can try to transfer the issuing right to another account with the <mark>supercede</mark> function.

Comment out everything in the playground function <mark>try_token_contract()</mark> to leave only the snippet below.


```python:
tok_ctrt_id = "your_token_contract_id"

tc = TokenContract(
    contract_id=tok_ctrt_id,
    split=True,
)

tc.supercede(
    by=ACNT_0,
    new_issuer=ACNT_1.address,
)
```

Run it by <mark>python main.py</mark> and call <mark>/contract/info/{contractId}</mark> to verify the changes. Below is an example response body.


```python:
{
  "contractId": "CF3XtMkL34hFPuDjsRiCPB2mitE8Nf8wwe3",
  "transactionId": "72oJ6qzBJw1ATGV6KTruFcPLEBeJ6yD4VwDhuEUU3Zu6",
  "type": "TokenContractWithSplit",
  "info": [
    {
      "data": "AU5NsHE8eC2guo3JobD8jrGvnEDQhBP8GtW",
      "type": "Address",
      "name": "issuer"
    },
    {
      "data": "AU6BNRK34SLuc27evpzJbAswB6ntHV2hmjD",
      "type": "Address",
      "name": "maker"
    }
  ],
  "height": 301588
}
```

Now the issuer role is played by another account.


## Troubleshooting

### Didn't See Changes via APIs?

- Ensure that you called the right API

- Ensure the transaction is broadcast(i.e. no error in the response dictionary returned by SDK functions. For example, <mark>pv.Account.execute_contract</mark>) 

- Wait for 5s for the transaction to be fully on chain

- Call <mark>/transactions/info/{id}</mark> to see if the transaction’s status is <mark>success</mark>