import 'katex/dist/katex.min.css';
import { InlineMath } from 'react-katex';
import vswapFlow from "./v_swap_flow.png";
import image001 from "./swap_exact_token_for_target_token.png";
import image002 from "./swap_token_for_exact_target_token.png";
import image003 from "./swap_exact_token_for_base_token.png";
import image004 from "./swap_token_for_exact_base_token.png";

<!-- KEYWORDS: V Swap Contract Smart Contract -->

# V Swap Contract

## Introduction

V Swap is an automated market making protocol. Prices are regulated by a constant product formula, and requires no action from the liquidity provider to maintain prices.

The contract allows completely decentralised exchanges to be formed, and allows anyone to be a liquidity provider as long as they have tokens on both sides of the swap.


## Implementation

The liquidity provided is tracked by a token called the liquidity token. The pool will give liquidity tokens according to the proportion of liquidity provided. These liquidity tokens should first be registered and completely issued before the liquidity pool is created.

The user who first creates the pool decides on an initial ratio, and the pool will create:
<br/>
<InlineMath math="number\_of\_minted\_liquidity\_tokens = \sqrt{\smash[b]{x}*{y}}"/>
<br/><br/>


number of liquidity tokens and give it to the liquidity provider.

Where x is the number of base tokens initially placed into the pool

And y is the number of target tokens initially placed into the pool

Subsequent liquidity providers will obtain liquidity tokens equal to
<br/>
<InlineMath math="number\_of\_minted\_liquidity\_tokens = \frac{({\smash[b]{a}*{b}}) * TotalLiquiditySupply}{x + y}"/>
<br/><br/>


Where a is the number of base tokens stored to the pool

And b is the number of target tokens stored to the pool


**A flow chart of the V Swap Contract is as follows:**

<img style={{ width: '100%'}} src={vswapFlow} />


The price of the swap is dependent on how many tokens are within the pool. By using an invariant, the price can be regulated automatically without the liquidity provider constantly updating the price.

<br/>
<InlineMath math="pool\_token\_A\_amount * pool\_token\_B\_amount = k"/>
<br/><br/>

It's important to note that the pool also takes 0.3% of the trade as fees.


## Using the VSYS Python API Wrapper pyvsystems

To generate and broadcast transactions, we can use <mark>pyvsystems</mark> to test contract functionalities on vsys chain.

### Install Pyvsystems

pyvsystems can be installed by first cloning the github repository

```
git clone https://github.com/virtualeconomy/pyvsystems.git
```

Then using pip, we can install the repository as a package

```
pip3 install pyvsystems/.
```


Then we can simply import <mark>pyvsystems</mark> in your own workplace.


### Register V Swap Contract

**Initialize API Connection**

```
import pyvsystems as pv
from pyvsystems import Account
from pyvsystems.contract import token_id_from_contract_id
from pyvsystems.contract_helper import *

custom_wrapper = pv.create_api_wrapper("<your_node_address>", api_key="<your_node_api_key (optional)>")
# chain = pv.Chain(chain_name='mainnet', chain_id='M', address_version=5, api_wrapper=custom_wrapper)
chain = pv.Chain(chain_name='devnet', chain_id='T', address_version=5, api_wrapper=custom_wrapper)
sender = Account(chain=chain, seed="<your_sender_seed>")
sender2 = Account(chain=chain, seed="<your_sender2_seed>")
```

<br/>

V Swap Contract ByteString:

```
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
```

<br/>

| **Triggers** 	|                        **Inputs**                        	|             **Input Types**            	|                                                                                                 **Description**                                                                                                 	|
|:------------:	|:--------------------------------------------------------:	|:--------------------------------------:	|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:	|
|     Init     	| (tokenAId, tokenBId, liquidityTokenId, minimumLiquidity) 	| (token_id, token_id, token_id, amount) 	| Initialize the swappable tokens and the liquidity pool token. The minimumLiquidity amount ensures that the liquidity inside the pool cannot be too small, as small liquidities lead to huge price fluctuations. 	|

<br/>

We can first register the liquidity token contract, token A and token B would normally already exist on chain, however, for testing purposes, we will also register those.

<br/>

```
v_swap_helper = VSwapContractHelper()

token_without_split_helper = TokenWithoutSplitContractHelper()

register_token_without_split1_data_stack = token_without_split_helper.register_data_stack_generator(<your_max_supply>, <your_unity>, "test token a")
register_token_without_split2_data_stack = token_without_split_helper.register_data_stack_generator(<your_max_supply>, <your_unity>, "test token b")
register_token_without_split3_data_stack = token_without_split_helper.register_data_stack_generator(<your_max_supply>, <your_unity>, "test token liquidity")

sender.register_contract(token_without_split_helper.contract_object, register_token_without_split1_data_stack)
sender.register_contract(token_without_split_helper.contract_object, register_token_without_split2_data_stack)
sender.register_contract(token_without_split_helper.contract_object, register_token_without_split3_data_stack)
```

```
token_a_contract_id = "<your_token_a_contract_id>"
token_b_contract_id = "<your_token_b_contract_id>"
liquidity_token_contract_id = "<your_liquidity_token_contract_id>"

token_a_id = "<your_token_a_id>"
token_b_id = "<your_token_b_id>"
liquidity_token_id = "<your_liquidity_token_id>"

register_v_swap_data_stack = v_swap_helper.register_data_stack_generator(token_a_id, token_b_id, liquidity_token_id, 10)

sender.register_contract(v_swap_helper.contract_object, register_v_swap_data_stack)
```

To test the contract, we will need to issue the test tokens and deposit them into the V Swap contract.

```
v_swap_contract_id = "<your_v_swap_contract_id>"

issue_token_a_data_stack = token_without_split_helper.issue_data_stack_generator(<your_issue_amount>)
issue_token_b_data_stack = token_without_split_helper.issue_data_stack_generator(<your_issue_amount>)
issue_liquidity_token_data_stack = token_without_split_helper.issue_data_stack_generator(<your_issue_amount>)

sender.execute_contract(token_a_contract_id, token_without_split_helper.issue_function_index, issue_token_a_data_stack)
sender.execute_contract(token_b_contract_id, token_without_split_helper.issue_function_index, issue_token_b_data_stack)
sender.execute_contract(liquidity_token_contract_id, token_without_split_helper.issue_function_index, issue_liquidity_token_data_stack)

deposit_token_a_data_stack = token_without_split_helper.deposit_data_stack_generator(sender.address, v_swap_contract_id, <your_deposit_amount>)
deposit_token_b_data_stack = token_without_split_helper.deposit_data_stack_generator(sender.address, v_swap_contract_id, <your_deposit_amount>)
deposit_liquidity_token_data_stack = token_without_split_helper.deposit_data_stack_generator(sender.address, v_swap_contract_id, <your_deposit_amount>)

sender.execute_contract(token_a_contract_id, token_without_split_helper.deposit_function_index, deposit_token_a_data_stack)
sender.execute_contract(token_b_contract_id, token_without_split_helper.deposit_function_index, deposit_token_b_data_stack)
sender.execute_contract(liquidity_token_contract_id, token_without_split_helper.deposit_function_index, deposit_liquidity_token_data_stack)
```
<br/>

**Using V Swap Contract Functions**

<br/>

|        Executable Functions       	| Function ID 	|                               Inputs                               	|                 Input Types                 	|                                                                              Description                                                                             	|
|:---------------------------------:	|:-----------:	|:------------------------------------------------------------------:	|:-------------------------------------------:	|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------:	|
|             Supersede             	|      0      	|                             (newOwner)                             	|                  (address)                  	|                                                                Give contract rights to another address                                                               	|
|              Set Swap             	|      1      	|                  (amountADesired, amountBDesired)                  	|               (address,amount)              	|                                                        Create a swap and deposit initial amounts into the pool                                                       	|
|           Add Liquidity           	|      2      	| (amountADesired, amountBDesired, amountAMin, amountBMin, deadline) 	| (amount, amount, amount, amount, timestamp) 	| Add liquidity to the pool, the amountA and amountB must be in the same proportion as the current pool (liquidity providers shouldn't change the price of the tokens) 	|
|          Remove Liquidity         	|      3      	|            (liquidity, amountAMin, amountBMin, deadline)           	|     (amount, amount, amount, timestamp)     	|                                                                           Remove liquidity                                                                           	|
|  Swap Token For Exact Base Token  	|      4      	|                 (amountOut, amountInMax, deadline)                 	|         (amount, amount, timestamp)         	|                       Set the amount of base tokens you would like to swap for, with a maximum number of target tokens you are willing to pay.                       	|
|  Swap Exact Tokens For Base Token 	|      5      	|                 (amountOutMin, amountIn, deadline)                 	|         (amount, amount, timestamp)         	|                    Set the amount of target tokens you would like to swap, and the minimum number of base tokens you need to receive in this swap                    	|
| Swap Token For Exact Target Token 	|      6      	|                 (amountOut, amountInMax, deadline)                 	|         (amount, amount, timestamp)         	|                      Set the amount of target tokens you would like to swap for, with the maximum number of base tokens you are willing to pay.                      	|
| Swap Exact Token For Target Token 	|      7      	|                 (amountOutMin, amountIn, deadline)                 	|         (amount, amount, timestamp)         	|                    Set the amount of base tokens you would like to swap, and the minimum number of target tokens you need to receive in this swap                    	|

<br/>

**Explanation of Base and Target Token**

The swap function names may be somewhat confusing for readers. But the 'Base Token' is simply 'Token A' while 'Target Token' is simply 'Token B', which was decided when the contract was registered. In reality, it makes very little difference which token is the 'Base Token' and which is the 'Target Token'. However, it is very important that the correct function is used. I will describe the scenarios where each function is appropriate.

In this contract, the base token is VSYS and the target token is TokenB. The price of each token is decided by the contract itself, so only one amount is input by the user, and the other amount can be calculated.

<br/>

**SWAP EXACT TOKEN FOR TARGET TOKEN**

<img style={{ width: '100%'}} src={image001} /><br/>

In this example, the user wants to swap 1000 VSYS, and obtains TokenB based on the pool. So the user wishes to swap for target token and has entered an exact base token amount. Thus, we should use the 'Swap Exact Token For Target Token' function. The second input 'amountIn' will be 1000, and the expected amount of target token out is calculated by:

<br/>
<InlineMath math="tokenB\_out = \frac{ reservedB * amount * 997}{(reservedVSYS * 1000) + (amount * 997)}"/>
<br/><br/>


The extra 997 / 1000 is used to take fees. The contract uses integer division, so tokenB_out is essentially rounded down.


The first input 'amountOutMin' determines the minimum 'tokenB_out' the trader is willing to accept. The calculation above calculates the exact amount of 'tokenB_out', but this assumes reservedVSYS and reservedB does not change in the process of confirming the trade. If the two reserved values do change (due to another trade happening at the same time), there will be a different 'tokenB_out' calculated when the trade really happens. This is referred to as slippage, and the 'amountOutMin' is there to determine the largest amount of slippage the trader is willing to tolerate.

<br/>

**SWAP TOKEN FOR EXACT TARGET TOKEN**

<img style={{ width: '100%'}} src={image002} /><br/>


Here instead we use 'Swap Token For Exact Target Token', as the user wishes to swap for target token and has entered an exact target token amount.

The calculation for this becomes:

<br/>
<InlineMath math="VSYS\_in = \frac{reservedVSYS * amount}{reservedB - amount} *  \frac{1000}{997}"/>
<br/><br/>


**SWAP EXACT TOKEN FOR BASE TOKEN**

<img style={{ width: '100%'}} src={image003} /><br/>


For this example, the user wants to swap for base tokens and has entered an exact target token amount. So we use 'Swap Exact Token For Base Token' function.

The calculation becomes:

<br/>
<InlineMath math="VSYS\_out = \frac{reservedVSYS * amount * 997}{(reservedB * 1000) + (amount * 997)}"/>
<br/><br/>


**SWAP EXACT TOKEN FOR BASE TOKEN**


<img style={{ width: '100%'}} src={image004} /><br/>

And finally, the user may want to swap for base tokens and enter an exact base token amount. Therefore we will use 'Swap Token For Exact Base Token' function.

And we will end up paying:

<br/>
<InlineMath math="tokenB\_in = \frac{reservedB * amount}{reservedVSYS - amount} *  \frac{1000}{997}"/>
<br/><br/>


**Supercede**

```
supersede_data_stack = v_swap_helper.supersede_data_stack_generator(sender2.address)

sender.execute_contract(v_swap_contract_id, v_swap_helper.supersede_function_index, supersede_data_stack)
```

<br/>

**Set Swap**
```
set_swap_data_stack = v_swap_helper.set_swap_data_stack_generator(10000, 10000)

sender.execute_contract(v_swap_contract_id, v_swap_helper.set_swap_function_index, set_swap_data_stack)
```

<br/>

**Add Liquidity**
```
add_liquidity_data_stack = v_swap_helper.add_liquidity_data_stack_generator(10000, 10000, 9000, 9000, 1629420568011521800)

sender.execute_contract(v_swap_contract_id, v_swap_helper.add_liquidity_function_index, add_liquidity_data_stack)
```

<br/>

**Remove Liquidity**
```
remove_liquidity_data_stack = v_swap_helper.remove_liquidity_data_stack_generator(10000, 10000, 10000, 1629420568011521800)

sender.execute_contract(v_swap_contract_id, v_swap_helper.remove_liquidity_function_index, remove_liquidity_data_stack)
```

<br/>

**Swap Token For Exact Base Token**
```
swap_token_for_exact_base_token_data_stack = v_swap_helper.swap_token_for_exact_base_token_data_stack_generator(1000, 1115, 1629420568011521800)

sender.execute_contract(v_swap_contract_id, v_swap_helper.swap_token_for_exact_base_token_function_index, swap_token_for_exact_base_token_data_stack)
```

<br/>

**Swap Exact Token For Base Token**
```
swap_exact_token_for_base_token_data_stack = v_swap_helper.swap_exact_token_for_base_token_data_stack_generator(740, 1000, 1629420568011521800)

sender.execute_contract(v_swap_contract_id, v_swap_helper.swap_exact_token_for_base_token_function_index, swap_exact_token_for_base_token_data_stack)
```

<br/>

**Swap Token For Exact Target Token**
```
swap_token_for_exact_target_token_data_stack = v_swap_helper.swap_token_for_exact_target_token_data_stack_generator(745, 1000, 1629420568011521800)

sender.execute_contract(v_swap_contract_id, v_swap_helper.swap_token_for_exact_target_token_function_index, swap_token_for_exact_target_token_data_stack)
```

<br/>

**Swap Exact Token For Target Token**
```
swap_exact_token_for_target_token_data_stack = v_swap_helper.swap_exact_token_for_target_token_data_stack_generator(814, 1000, 1629420568011521800)

sender.execute_contract(v_swap_contract_id, v_swap_helper.swap_exact_token_for_target_token_function_index, swap_exact_token_for_base_token_data_stack)
```

## Front Run Test

It is important to understand that the VSYS blockchain prioritises transactions with higher transaction fees, so that someone is able to force their trades to be confirmed before yours. Since trades end up changing the price for subsequent trades, trades that are front run may end up losing money to slippage (price changes that occur between the trade is sent, and the trade is finalised).
<br/>

```
register_token_without_split1_data_stack = token_without_split_helper.register_data_stack_generator(1000000000, 1000, "test token a")
register_token_without_split2_data_stack = token_without_split_helper.register_data_stack_generator(1000000000, 1000, "test token b")
register_token_without_split3_data_stack = token_without_split_helper.register_data_stack_generator(1000000000, 1000, "test token liquidity")

sender.register_contract(token_without_split_helper.contract_object, register_token_without_split1_data_stack)
sender.register_contract(token_without_split_helper.contract_object, register_token_without_split2_data_stack)
sender.register_contract(token_without_split_helper.contract_object, register_token_without_split3_data_stack)

token_a_contract_id = "<your_token_a_contract_id>"
token_b_contract_id = "<your_token_b_contract_id>"
liquidity_token_contract_id = "<your_liquidity_token_contract_id>"

token_a_id = "<your_token_a_id>"
token_b_d = "<your_token_b_id>"
liquidity_token_id = "<your_liquidity_token_contract_id>"

register_v_swap_data_stack = v_swap_helper.register_data_stack_generator(token_a_id, token_b_d, liquidity_token_id, 10)

v_swap_contract_id = "<your_v_swap_contract_id>"

issue_token_a_data_stack = token_without_split_helper.issue_data_stack_generator(1000000000)
issue_token_b_data_stack = token_without_split_helper.issue_data_stack_generator(1000000000)
issue_liquidity_token_data_stack = token_without_split_helper.issue_data_stack_generator(1000000000)

sender.execute_contract(token_a_contract_id, token_without_split_helper.issue_function_index, issue_token_a_data_stack)
sender.execute_contract(token_b_contract_id, token_without_split_helper.issue_function_index, issue_token_b_data_stack)
sender.execute_contract(liquidity_token_contract_id, token_without_split_helper.issue_function_index, issue_liquidity_token_data_stack)

deposit_token_a_data_stack = token_without_split_helper.deposit_data_stack_generator(sender.address, v_swap_contract_id, 1000000000)
deposit_token_b_data_stack = token_without_split_helper.deposit_data_stack_generator(sender.address, v_swap_contract_id, 1000000000)
deposit_liquidity_token_data_stack = token_without_split_helper.deposit_data_stack_generator(sender.address, v_swap_contract_id, 1000000000)

sender.execute_contract(token_a_contract_id, token_without_split_helper.deposit_function_index, deposit_token_a_data_stack)
sender.execute_contract(token_b_contract_id, token_without_split_helper.deposit_function_index, deposit_token_b_data_stack)
sender.execute_contract(liquidity_token_contract_id, token_without_split_helper.deposit_function_index, deposit_liquidity_token_data_stack)

set_swap_data_stack = v_swap_helper.set_swap_data_stack_generator(10000, 10000)

sender.execute_contract(v_swap_contract_id, v_swap_helper.set_swap_function_index, set_swap_data_stack)

swap_token_for_exact_base_token_data_stack = v_swap_helper.swap_token_for_exact_base_token_data_stack_generator(1000, 1115, 1629420568011521800)

sender.execute_contract(v_swap_contract_id, v_swap_helper.swap_token_for_exact_base_token_function_index, swap_token_for_exact_base_token_data_stack, tx_fee=40000000) # The front running trade

sender.execute_contract(v_swap_contract_id, v_swap_helper.swap_token_for_exact_base_token_function_index, swap_token_for_exact_base_token_data_stack) # This swap will fail, since the trade was front run
```

<br />

**Database Queries**

| **State Variable** 	| **State Variable Index** 	|                             **Description**                             	|
|:------------------:	|:------------------------:	|:-----------------------------------------------------------------------:	|
|        maker       	|             0            	|             The address of the creator of the lock contract             	|
|      tokenAId      	|             1            	|                The token id of the first swappable token                	|
|      tokenBId      	|             2            	|                                                                         	|
|  tokenLiquidityId  	|             3            	|                   The token id of the liquidity token                   	|
|     swapStatus     	|             4            	|               Whether or not the swap is currently active               	|
|  minimumLiquidity  	|             5            	| The minimum liquidity that can be in the pool, this cannot be withdrawn 	|
|   tokenAReserved   	|             6            	|                  The amount of token A inside the pool                  	|
|   tokenBReserved   	|             7            	|                  The amount of token B inside the pool                  	|
|     totalSupply    	|             8            	|                Total liquidity tokens that can be minted                	|
| liquidityTokenLeft 	|             9            	|                     The liquidity left to be minted                     	|

<br />

|   **State Map**  	| **State Map Index** 	|   **State Map Key**  	|                                    **Description**                                   	|
|:----------------:	|:-------------------:	|:--------------------:	|:------------------------------------------------------------------------------------:	|
|   tokenABalance  	|          0          	| userAddress(address) 	|      The balance of token A stored within this contract belonging to userAddress     	|
|   tokenBBalance  	|          1          	| userAddress(address) 	|      The balance of token B stored within this contract belonging to userAddress     	|
| liquidityBalance 	|          2          	| userAddress(address) 	| The balance of liquidity tokens stored within this contract belonging to userAddress 	|

<br />

```
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.maker_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.token_a_id_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.token_b_id_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.liquidity_token_id_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.swap_status_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.minimum_liquidity_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.token_a_reserved_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.token_b_reserved_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.total_supply_db_key_generator()))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.liquidity_token_left_db_key_generator()))

print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.token_a_balance_db_key_generator(sender.address)))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.token_b_balance_db_key_generator(sender.address)))
print(chain.contract_db_query(v_swap_contract_id, v_swap_helper.liquidity_token_balance_db_key_generator(sender.address)))
```