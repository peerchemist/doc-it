<!-- KEYWORDS: Atomic Swap Contract -->

# V Atomic Swap Contract

## introduction

The Atomic Swap is a method of swapping coins or tokens in a secure manner that requires no trusted party to hold custody of the coins. When swapping coins, the two untrusted party runs into a problem, whoever gets sent the coins first can simply abandon the deal and run off with the coins.

The Atomic Swap solves this issue by using the properties of a hash function, that the hash function is deterministic (the same input gives the same output), and that it cannot be reversed (the input cannot be determined from the output).


## Example

You will understand what atomic swap contract does in v.systems with the following example.

Let’s take Alice and Bob as an example. Alice wants to exchange 1 BTC for 3 ETH with Bob. For safety reasons, they use the atomic swap contract.

First, Alice will create a secret A and hash it, get Hash(secret A). Since hash value is infeasible to reverse, no one should be able to get Secret A from Hash(Secret A).

Alice then creates an Atomic swap contract Contract A, and then deposit 1 BTC into the contract. There will be two different situations:

1. If Alice broadcasts secret A before timestamp B, Contract A will transfer 1 BTC to Bob’s address.

2. If nothing is done before timestamp A, 1 BTC will return to Alice’s address.

Then Bob creates an Atomic Swap contract Contract B and then deposit 3 ETH into the contract. There will be two different situations:

1. If Alice has broadcasted secret A before timestamp B, Contract B can get secret A to transfer 3 ETH to Alice’s address.

2. If nothing is done before timestamp B, 3 ETH will return to Bob’s address.

Remember that timestamp B must be earlier than timestamp A, otherwise, Alice may withdraw 1 BTC and receive Bob’s 3 ETH.


## Implementation

The VSYS Atomic Swap contract can store a single type of Token. To swap between different Tokens, two separate contracts are necessary. Users are required to deposit Tokens into the contract before they are able to lock it.

The **lock** function itself is fairly simplistic, the input should be the hash of some secret together with the determined recipient and an expiration timestamp. To unlock the lock, the recipient simply needs to call the **SolvePuzzle** function with the transaction id of the lock together with the secret.

The contract will check that the hash of the secret matches the puzzle in the lock. If it matches, the contract will transfer ownership of the locked coins or tokens to the recipient. Note, however, that while the funds change ownership, they stay within the contract, so the wallet's balance won't change until the recipient withdraws the funds from the contract.


## Using the VSYS Python API Wrappers pyvsystems

To generate and broadcast transactions, we can use pyvsystems to test contract functionalities on the VSYS chain.

### Install pyvsystems

**pyvsystems** can be installed by first cloning the github repository.

```python:
git clone https://github.com/virtualeconomy/pyvsystems.git
```

Then using pip, we can install the repository as a package.

```python:
pip3 install pyvsystems/.
```

Now you can import pyvsystems in your own workplace.

register an atomic swap contract


### Initialize the API Connection

**Data Required:**

1. Node host
2. Api key
3. Seeds for two account


```python:
import pyvsystems as pv
from pyvsystems import Account
from pyvsystems.contract import token_id_from_contract_id, data_entry_from_base58_str
from pyvsystems.crypto import sha256
from pyvsystems.contract_helper import *

custom_wrapper = pv.create_api_wrapper('<your_node_ip>', api_key='<your_node_api_key>')
chain = pv.Chain(chain_name='mainnet', chain_id='M', address_version=5, api_wrapper=custom_wrapper)
sender1 = Account(chain=chain, seed='<your_account1_seed>', nonce=0)
sender2 = Account(chain=chain, seed='<your_account2_seed>', nonce=0)
```


### Register Swap Contracts

Each swap contract can only store one type of token or coin, and needs to be determined when the contracts are registered.

**Data Required:**

1. Two token ids.

```python:
# Register a swap contract that stores the two respective tokens
# Note that sender1 owns token1, while sender2 owns token2
atomic_swap_helper = AtomicSwapContractHelper()
system_helper = SystemContractHelper()
swap_contract = Contract(Contract_Atomic_Swap)

token1_id_data_entry = DataEntry(token1_id, Type.token_id)
init_swap1_data_stack = [token1_id_data_entry]
register_swap1_response = sender1.register_contract(swap_contract, init_swap1_data_stack)

token2_id_data_entry = DataEntry(token2_id, Type.token_id)
init_swap2_data_stack = [token2_id_data_entry]
register_swap2_response = sender2.register_contract(swap_contract, init_swap2_data_stack)
```

### Deposit into Swap Contracts

Contracts can only interact with tokens or coins deposited into them, therefore before the tokens can be locked and swapped, they must be deposited into the Swap Contracts.

**Data Required:**

1. Two sender's addresses.
2. Two Swap contracts' id.
3. The amount you want to deposit into 2 contracts.
4. Two token contracts' id.


```python:
# After registering the two swap contracts, we can deposit into them
# using their contract ids

deposit1_data_stack = token_without_split_helper.deposit_data_stack_generator(sender1.address, swap1_contract_id, deposit_amount)
deposit2_data_stack = token_without_split_helper.deposit_data_stack_generator(sender2.address, swap2_contract_id, 1000)

sender1.execute_contract(token1_contract_id, token_without_split_helper.deposit_function_index, deposit1_data_stack)
sender2.execute_contract(token2_contract_id, token_without_split_helper.deposit_function_index, deposit2_data_stack)
```


### Lock the Deposited Funds

The transaction that locks the funds are public on the blockchain, so it is simple to observe the resulting hash of the secret. Ensure that both locks use the same hash so that when the first lock is unlocked, the secret is revealed.

**Data Required:**

1. Your Secret(like "abc")
2. Swap Amount for Both
3. sender1 and sender2’s addresses
4. Timestamp1
5. Swap Contacts' id.


```python:
# After depositing both tokens into their respective swap contracts
# we can lock them both, ensuring that the second timestamp is lower than the first

# First decide on a secret, hash and encode it

secret = "abc"
encoded_secret_hash_string = bytes2str(base58.b58encode(sha256(secret)))

lock1_data_stack = atomic_swap_helper.lock_data_stack_generator(lock_amount, sender2.address, encoded_secret_hash_string, timestamp1)
#execute print the tx id
print(sender1.execute_contract(swap1_contract_id, atomic_swap_helper.lock_function_index, lock1_data_stack))

# Lock id is the tx id of the lock transaction
lock1_id = "tx_id_of_lock"

# Sender2 would be able to find the hash string by decoding the lock transaction data

lock1_function_data = chain.contract_db_query(swap1_contract_id, atomic_swap_helper.swap_puzzle_db_key_generator(lock1_id))

tx_data_encoded_secret_hash_string = data_entry_from_base58_str(lock1_function_data['value'])

swap2_amount_data_entry = DataEntry(amount_for_swap2, Type.amount)
swap2_recipient_data_entry = DataEntry(sender1.address, Type.address)
swap2_puzzle_data_entry = DataEntry(tx_data_encoded_secret_hash_string, Type.short_bytes_string)
swap2_timestamp_data_entry = DataEntry(timestamp2, Type.timestamp)

swap2_lock_data_stack = [swap2_amount_data_entry, swap2_recipient_data_entry, swap2_puzzle_data_entry, swap2_timestamp_data_entry]

lock2_response = sender2.execute_contract(swap2_contract_id, 0, swap2_lock_data_stack)
lock2_tx_id = lock2_response['id']
```


### Solve the Puzzles

Solving both puzzles will complete the swap. Once the first puzzle is solved the secret is revealed to the entire blockchain and can be found using the transaction's functionData. Sender2 will be able to decode this data and unlock the first lock.

**Data Required:**

1. Your Secret(like "abc")
2. lock1/2 tx id
3. swap contracts' id


```python:
# Once we properly lock the funds, sender1 will first solve the lock

swap1_lock_txid_data_entry = DataEntry(lock2_tx_id, Type.short_bytes_string)
swap1_lock_key_data_entry = DataEntry("abc", Type.short_bytes)

swap1_solve_data_stack = [swap1_lock_tx_id_data_entry, swap1_lock_key_data_entry]

solve1_response = sender1.execute_contract(swap2_contract_id, 1, swap1_solve_data_stack)

# Sender2 can then look at the function data to find the solution
# This transaction id can be found by looking at the transactions of sender1 for example.

solve1_function_data = chain.api_wrapper.request('transactions/info/%s'%(solve1_response['id']))['functionData']

solve_key = bytes2str(base58.b58decode(data_entry_from_base58_str(solve1_function_data)[1].data))

# The chain stores the input data as a base58 encoded string of the bytes.
# The inputs to contracts are always data entries, so it is simple to parse the data into data entries.
# The input is also base58 encoded, so we will have to base58 decode the final value.

revealed_secret = base58.b58decode(data_entry_from_base58_str(solve1_function_data['value']))

solve_puzzle2_data_stack = atomic_swap_helper.solve_puzzle_data_stack_generator(lock1_tx_id, base58.b58encode(revealed_secret))

sender2.execute_contract(swap1_contract_id, atomic_swap_helper.solve_puzzle_function_index, solve_puzzle2_data_stack)

```

### Withdraws the Funds

Once the puzzle is solved, the ownership of the tokens has changed, however, the funds remain in the contract until they are withdrawn.

**Data Required:**

1. swap contracts' id.
2. senders' addresses.
3. token contracts' id.


```python:
# After transferring ownership of tokens, we can withdraw them

withdraw1_data_stack = token_without_split_helper.withdraw_data_stack_generator(swap2_contract_id, sender1.address, 1000)

withdraw2_data_stack = token_without_split_helper.withdraw_data_stack_generator(swap1_contract_id, sender2.address, 1000)

sender1.execute_contract(token2_contract_id, token_without_split_helper.withdraw_function_index, withdraw1_data_stack)

sender2.execute_contract(token1_contract_id, token_without_split_helper.withdraw_function_index, withdraw2_data_stack)
```

## Cross-chain Swap Example

The following example contains an example of a Eth-VSYS atomic swap, done using <mark>Truffle</mark> to simulate the Ethereum blockchain in a test environment.


> Before you continue, the following example requires some knowledge with the Ethereum Blockchain and Solidity.


First we install Truffle by:

```
$ npm install -g truffle
```

Then create a directory to contain Ethereum smart contracts and cd into it

```
$ mkdir /chosen/path/truffle-swap
$ cd /chosen/path/truffle-swap
```

Then we initialise an empty Truffle project

```
$ truffle init
```

Next we save the following solidity contract as AtomicSwapEther.sol in /chosen/path/truffle-swap/contracts which should be created upon truffle init.


```
pragma solidity ^0.5.0;


contract AtomicSwapEther {
    struct Swap {
        uint256 timelock;
        uint256 value;
        address payable ethTrader;
        address payable withdrawTrader;
        bytes32 secretLock;
        bytes secretKey;
    }

    enum States {
        INVALID,
        OPEN,
        CLOSED,
        EXPIRED
    }

    mapping (bytes32 => Swap) private swaps;
    mapping (bytes32 => States) private swapStates;

    event Open(bytes32 _swapID, address _withdrawTrader, bytes32 _secretLock);
    event Expire(bytes32 _swapID);
    event Close(bytes32 _swapID, bytes _secretKey);

    modifier onlyInvalidSwaps(bytes32 _swapID) {
        require(swapStates[_swapID] == States.INVALID);
        _;
    }

    modifier onlyOpenSwaps(bytes32 _swapID) {
        require(swapStates[_swapID] == States.OPEN);
        _;
    }

    modifier onlyClosedSwaps(bytes32 _swapID) {
        require(swapStates[_swapID] == States.CLOSED);
        _;
    }

    modifier onlyExpirableSwaps(bytes32 _swapID) {
        require(now >= swaps[_swapID].timelock);
        _;
    }

    modifier onlyWithSecretKey(bytes32 _swapID, bytes memory _secretKey) {
        // TODO: Require _secretKey length to conform to the spec
        require(swaps[_swapID].secretLock == sha256(_secretKey));
        _;
    }

    function open(bytes32 _swapID, address payable _withdrawTrader, bytes32 _secretLock,
        uint256 _timelock) public onlyInvalidSwaps(_swapID) payable {

        // Store the details of the swap.
        Swap memory swap = Swap({
            timelock: _timelock,
            value: msg.value,
            ethTrader: msg.sender,
            withdrawTrader: _withdrawTrader,
            secretLock: _secretLock,
            secretKey: new bytes(0)
        });
        swaps[_swapID] = swap;
        swapStates[_swapID] = States.OPEN;

        // Trigger open event.
        emit Open(_swapID, _withdrawTrader, _secretLock);
    }

    function close(bytes32 _swapID, bytes memory _secretKey) public onlyOpenSwaps(_swapID)
        onlyWithSecretKey(_swapID, _secretKey) {

        // Close the swap.
        Swap memory swap = swaps[_swapID];
        swaps[_swapID].secretKey = _secretKey;
        swapStates[_swapID] = States.CLOSED;

        // Transfer the ETH funds from this contract to the withdrawing trader.
        swap.withdrawTrader.transfer(swap.value);

        // Trigger close event.
        emit Close(_swapID, _secretKey);
    }

    function expire(bytes32 _swapID) public onlyOpenSwaps(_swapID) onlyExpirableSwaps(_swapID) {
        // Expire the swap.
        Swap memory swap = swaps[_swapID];
        swapStates[_swapID] = States.EXPIRED;

        // Transfer the ETH value from this contract back to the ETH trader.
        swap.ethTrader.transfer(swap.value);

        // Trigger expire event.
        emit Expire(_swapID);
    }

    function check(bytes32 _swapID) public view returns (uint256 timelock, uint256 value,
        address withdrawTrader, bytes32 secretLock) {

        Swap memory swap = swaps[_swapID];
        return (swap.timelock, swap.value, swap.withdrawTrader, swap.secretLock);
    }

    function checkSecretKey(bytes32 _swapID) public view onlyClosedSwaps(_swapID) returns (bytes memory secretKey) {
        Swap memory swap = swaps[_swapID];
        return swap.secretKey;
    }
}
```


create a javascript file in the /chosen/path/truffle-swap/migrations called '2_deploy_contracts.js' so that we can automatically deploy contracts on truffle start up.


```
const AtomicSwapEther = artifacts.require("AtomicSwapEther");

module.exports = function(deployer) {
  deployer.deploy(AtomicSwapEther);
}
```

The contract can now be automatically deployed into the test environment by


```
$ truffle migrate
```

Next we enter the truffle development environment which automatically creates 10 accounts with a large amount of test Eth.


```
$ truffle develop
```

Save the accounts into a variable


```
truffle(develop)> let accounts = await web3.eth.getAccounts();
```

Set up the atomic swap instance so we can interact with the contract


```
truffle(develop)> const SwapInstance = await AtomicSwapEther.deployed();
```


Truffle allows a very easy method to interact with contracts as if they were functions, on the real Ethereum chain, the correct form of the messages accessing the contracts' code must be ensured.

First let's open a channel and send some Eth to the contract. The variables we need to open a channel are: (bytes32 _swapID, address payable _withdrawTrader, bytes32 _secretLock, uint256 _timelock)

The secret lock here can be obtained by using the Sha256 hash on the string "abc" and adding "0x" to the front, which is Ethereum's way of denoting hexadecimal data. It doesn't seem like web3 has the Sha256 hash function, so you can simply use any other source of Sha256 hashing and add "0x" to the front. Or you can simply copy this secretLock and know the secret is "abc".

```
truffle(develop)> let swapID = web3.utils.fromUtf8("123456789");
truffle(develop)> let withdrawTrader = accounts[1];
truffle(develop)> let secretLock = "0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad";
truffle(develop)> let timelock = 1000000000000000;
```

Then open the Atomic Swap

```
truffle(develop)> SwapInstance.open(swapID, withdrawTrader, secretLock, timelock, {from: accounts[0], value: web3.utils.toWei('2', 'ether')})
```

Now that we've opened this on Ethereum we can open a similar swap contract on VSYS to complete the swap.


### Import package pyvsystems

```
import pyvsystems as pv
from pyvsystems import Account
from pyvsystems.contract import token_id_from_contract_id
from pyvsystems.crypto import bytes2str, sha256
from pyvsystems.contract_helper import *
```

**Setup** 

Ensure valid accounts are used, and the token id and contract id of the token to swap should be known.

```
custom_wrapper = pv.create_api_wrapper('<your_node_ip>', api_key='<your_node_api_key>')
chain = pv.Chain(chain_name='mainnet', chain_id='M', address_version=5, api_wrapper=custom_wrapper)
sender1 = Account(chain=chain, seed='<your_account1_seed>', nonce=0)
sender2 = Account(chain=chain, seed='<your_account2_seed>', nonce=0)
```

We'll test swapping VSYS using the system contract for Ethereum. First we register a swap contract that can store VSYS.

```
atomic_swap_helper = AtomicSwapContractHelper()
system_helper = SystemContractHelper()

system_contract_id = chain.system_contract_id()
system_token_id = token_id_from_contract_id(system_contract_id, 0)

register_swap_data_stack = atomic_swap_helper.register_data_stack_generator(system_token_id)

sender1.register_contract(atomic_swap_helper.contract_object, register_swap_data_stack)

swap_contract_id = "<your_atomic_swap_contract_id>"
```

Next we deposit into the contract

```
deposit_data_stack = system_helper.deposit_data_stack_generator(sender1.address, swap_contract_id, 100000000000)

sender1.execute_contract(system_contract_id, system_helper.deposit_function_index, deposit_data_stack)
```

Before we lock the contract, we must know what the puzzle should be. This can be found by executing the 'check' function in the Ethereum atomic swap contract.

```
truffle(develop)> SwapInstance.check(swapID);
Result {
  '0': BN {
    negative: 0,
    words: [ 13008896, 14901161, <1 empty item> ],
    length: 2,
    red: null
  },
  '1': BN {
    negative: 0,
    words: [ 46661632, 5986771, 444, <1 empty item> ],
    length: 3,
    red: null
  },
  '2': '0x386e28ad27f73C1732540C68C08c423AA8e43dCc',
  '3': '0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad',
  timelock: BN {
    negative: 0,
    words: [ 13008896, 14901161, <1 empty item> ],
    length: 2,
    red: null
  },
  value: BN {
    negative: 0,
    words: [ 46661632, 5986771, 444, <1 empty item> ],
    length: 3,
    red: null
  },
  withdrawTrader: '0x386e28ad27f73C1732540C68C08c423AA8e43dCc',
  secretLock: '0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad'
}
```

As we can see, the 'secretLock' is seen to be "0xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad". However, the "0x" in front is a convention on the Ethereum network to represent hexadecimal. Since VSYS prefers to use base58 encoded strings, we must first obtain the pure byte form of the puzzle after dropping the "0x", and then encode it using base58.

```
puzzle_hexstring = "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
puzzle_bytes = bytes.fromhex(puzzle_hexstring)

encoded_secret_hash_string = bytes2str(base58.b58encode(puzzle_bytes))

swap_amount_data_entry = DataEntry(1000000, Type.amount)
swap_recipient_data_entry = DataEntry(sender2.address, Type.address)
swap_puzzle_data_entry = DataEntry(encoded_secret_hash_string, Type.short_bytes_string)
swap_timestamp_data_entry = DataEntry(17000000000000000000, Type.timestamp)

swap_lock_data_stack = [swap_amount_data_entry, swap_recipient_data_entry, swap_puzzle_data_entry, swap_timestamp_data_entry]

lock_response = sender1.execute_contract(swap_contract_id, 0, swap_lock_data_stack)
```

Once the contract is locked, the other user can solve the lock, which reveals the secret key.

```
lock_txid = lock_response['id']

swap_lock_txid_data_entry = DataEntry(lock_txid, Type.short_bytes_string)
swap_lock_key_data_entry = DataEntry("abc", Type.short_bytes)

swap_solve_data_stack = [swap_lock_txid_data_entry, swap_lock_key_data_entry]

solve_response = sender2.execute_contract(swap_contract_id, 1, swap_solve_data_stack)
```

We can query the blockchain for the function data in the execute contract, which must contain the correct secret key if the lock gets opened.


```
solve_function_data = chain.api_wrapper.request('transactions/info/%s'%(solve_response['id']))['functionData']

solve_key = bytes2str(base58.b58decode(data_entry_from_base58_str(solve1_function_data)[1].data))
```

The secret is now revealed to be "abc" which can be used to close the Ethereum smart contract. Note that the Ethereum atomic swap implementation uses the hex representation of the string, so we will need to change it from Utf8 representation.


```
truffle(develop)> let secret_key = web3.utils.fromUtf8("abc");

truffle(develop)> SwapInstance.close(swapID, secret_key, {from: accounts[1]});
```