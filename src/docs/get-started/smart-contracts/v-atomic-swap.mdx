<!-- KEYWORDS: Atomic Swap Contract -->

# Introduction

The Atomic Swap is a method of swapping coins or tokens in a secure manner that requires no trusted party to hold custody of the coins. When swapping coins, the two untrusted party runs into a problem, whoever gets sent the coins first can simply abandon the deal and run off with the coins.

The Atomic Swap solves this issue by using the properties of a hash function, that the hash function is deterministic (the same input gives the same output), and that it cannot be reversed (the input cannot be determined from the output).


## Example

You will understand what atomic swap contract does in v.systems with the following example.

Let’s take Alice and Bob as an example. Alice wants to exchange 1 BTC for 3 ETH with Bob. For safety reasons, they use the atomic swap contract.

First, Alice will create a secret A and hash it, get Hash(secret A). Since hash value is infeasible to reverse, no one should be able to get Secret A from Hash(Secret A).

Alice then creates an Atomic swap contract Contract A, and then deposit 1 BTC into the contract. There will be two different situations:

1. If Alice broadcasts secret A before timestamp B, Contract A will transfer 1 BTC to Bob’s address.

2. If nothing is done before timestamp A, 1 BTC will return to Alice’s address.

Then Bob creates an Atomic Swap contract Contract B and then deposit 3 ETH into the contract. There will be two different situations:

1. If Alice has broadcasted secret A before timestamp B, Contract B can get secret A to transfer 3 ETH to Alice’s address.

2. If nothing is done before timestamp B, 3 ETH will return to Bob’s address.

Remember that timestamp B must be earlier than timestamp A, otherwise, Alice may withdraw 1 BTC and receive Bob’s 3 ETH.


## Implementation

The VSYS Atomic Swap contract can store a single type of Token. To swap between different Tokens, two separate contracts are necessary. Users are required to deposit Tokens into the contract before they are able to lock it.

The **lock** function itself is fairly simplistic, the input should be the hash of some secret together with the determined recipient and an expiration timestamp. To unlock the lock, the recipient simply needs to call the **SolvePuzzle** function with the transaction id of the lock together with the secret.

The contract will check that the hash of the secret matches the puzzle in the lock. If it matches, the contract will transfer ownership of the locked coins or tokens to the recipient. Note, however, that while the funds change ownership, they stay within the contract, so the wallet's balance won't change until the recipient withdraws the funds from the contract.


## Using the VSYS Python API Wrappers pyvsystems

To generate and broadcast transactions, we can use pyvsystems to test contract functionalities on the VSYS chain.

### Install pyvsystems

**pyvsystems** can be installed by first cloning the github repository.

```python:
git clone https://github.com/virtualeconomy/pyvsystems.git
```

Then using pip, we can install the repository as a package.

```python:
pip3 install pyvsystems/.
```

Now you can import pyvsystems in your own workplace.

register an atomic swap contract


### Initialize the API Connection

**Data Required:**

1. Node host
2. Api key
3. Seeds for two account


```python:
import pyvsystems as pv
from pyvsystems import Account
from pyvsystems.contract import token_id_from_contract_id, data_entry_from_base58_str
from pyvsystems.crypto import sha256
from pyvsystems.contract_helper import *

custom_wrapper = pv.create_api_wrapper('<your_node_ip>', api_key='<your_node_api_key>')
chain = pv.Chain(chain_name='mainnet', chain_id='M', address_version=5, api_wrapper=custom_wrapper)
sender1 = Account(chain=chain, seed='<your_account1_seed>', nonce=0)
sender2 = Account(chain=chain, seed='<your_account2_seed>', nonce=0)
```


### Register Swap Contracts

Each swap contract can only store one type of token or coin, and needs to be determined when the contracts are registered.

**Data Required:**

1. Two token ids.

```python:
# Register a swap contract that stores the two respective tokens
# Note that sender1 owns token1, while sender2 owns token2
atomic_swap_helper = AtomicSwapContractHelper()
system_helper = SystemContractHelper()
swap_contract = Contract(Contract_Atomic_Swap)

token1_id_data_entry = DataEntry(token1_id, Type.token_id)
init_swap1_data_stack = [token1_id_data_entry]
register_swap1_response = sender1.register_contract(swap_contract, init_swap1_data_stack)

token2_id_data_entry = DataEntry(token2_id, Type.token_id)
init_swap2_data_stack = [token2_id_data_entry]
register_swap2_response = sender2.register_contract(swap_contract, init_swap2_data_stack)
```

### Deposit into Swap Contracts

Contracts can only interact with tokens or coins deposited into them, therefore before the tokens can be locked and swapped, they must be deposited into the Swap Contracts.

**Data Required:**

1. Two sender's addresses.
2. Two Swap contracts' id.
3. The amount you want to deposit into 2 contracts.
4. Two token contracts' id.


```python:
# After registering the two swap contracts, we can deposit into them
# using their contract ids

deposit1_data_stack = token_without_split_helper.deposit_data_stack_generator(sender1.address, swap1_contract_id, deposit_amount)
deposit2_data_stack = token_without_split_helper.deposit_data_stack_generator(sender2.address, swap2_contract_id, 1000)

sender1.execute_contract(token1_contract_id, token_without_split_helper.deposit_function_index, deposit1_data_stack)
sender2.execute_contract(token2_contract_id, token_without_split_helper.deposit_function_index, deposit2_data_stack)
```


### Lock the Deposited Funds

The transaction that locks the funds are public on the blockchain, so it is simple to observe the resulting hash of the secret. Ensure that both locks use the same hash so that when the first lock is unlocked, the secret is revealed.

**Data Required:**

1. Your Secret(like "abc")
2. Swap Amount for Both
3. sender1 and sender2’s addresses
4. Timestamp1
5. Swap Contacts' id.


```python:
# After depositing both tokens into their respective swap contracts
# we can lock them both, ensuring that the second timestamp is lower than the first

# First decide on a secret, hash and encode it

secret = "abc"
encoded_secret_hash_string = bytes2str(base58.b58encode(sha256(secret)))

lock1_data_stack = atomic_swap_helper.lock_data_stack_generator(lock_amount, sender2.address, encoded_secret_hash_string, timestamp1)
#execute print the tx id
print(sender1.execute_contract(swap1_contract_id, atomic_swap_helper.lock_function_index, lock1_data_stack))

# Lock id is the tx id of the lock transaction
lock1_id = "tx_id_of_lock"

# Sender2 would be able to find the hash string by decoding the lock transaction data

lock1_function_data = chain.contract_db_query(swap1_contract_id, atomic_swap_helper.swap_puzzle_db_key_generator(lock1_id))

tx_data_encoded_secret_hash_string = data_entry_from_base58_str(lock1_function_data['value'])

swap2_amount_data_entry = DataEntry(amount_for_swap2, Type.amount)
swap2_recipient_data_entry = DataEntry(sender1.address, Type.address)
swap2_puzzle_data_entry = DataEntry(tx_data_encoded_secret_hash_string, Type.short_bytes_string)
swap2_timestamp_data_entry = DataEntry(timestamp2, Type.timestamp)

swap2_lock_data_stack = [swap2_amount_data_entry, swap2_recipient_data_entry, swap2_puzzle_data_entry, swap2_timestamp_data_entry]

lock2_response = sender2.execute_contract(swap2_contract_id, 0, swap2_lock_data_stack)
lock2_tx_id = lock2_response['id']
```


### Solve the Puzzles

Solving both puzzles will complete the swap. Once the first puzzle is solved the secret is revealed to the entire blockchain and can be found using the transaction's functionData. Sender2 will be able to decode this data and unlock the first lock.

**Data Required:**

1. Your Secret(like "abc")
2. lock1/2 tx id
3. swap contracts' id


```python:
# Once we properly lock the funds, sender1 will first solve the lock

swap1_lock_txid_data_entry = DataEntry(lock2_tx_id, Type.short_bytes_string)
swap1_lock_key_data_entry = DataEntry("abc", Type.short_bytes)

swap1_solve_data_stack = [swap1_lock_tx_id_data_entry, swap1_lock_key_data_entry]

solve1_response = sender1.execute_contract(swap2_contract_id, 1, swap1_solve_data_stack)

# Sender2 can then look at the function data to find the solution
# This transaction id can be found by looking at the transactions of sender1 for example.

solve1_function_data = chain.api_wrapper.request('transactions/info/%s'%(solve1_response['id']))['functionData']

solve_key = bytes2str(base58.b58decode(data_entry_from_base58_str(solve1_function_data)[1].data))

# The chain stores the input data as a base58 encoded string of the bytes.
# The inputs to contracts are always data entries, so it is simple to parse the data into data entries.
# The input is also base58 encoded, so we will have to base58 decode the final value.

revealed_secret = base58.b58decode(data_entry_from_base58_str(solve1_function_data['value']))

solve_puzzle2_data_stack = atomic_swap_helper.solve_puzzle_data_stack_generator(lock1_tx_id, base58.b58encode(revealed_secret))

sender2.execute_contract(swap1_contract_id, atomic_swap_helper.solve_puzzle_function_index, solve_puzzle2_data_stack)

```

### Withdraws the Funds

Once the puzzle is solved, the ownership of the tokens has changed, however, the funds remain in the contract until they are withdrawn.

**Data Required:**

1. swap contracts' id.
2. senders' addresses.
3. token contracts' id.


```python:
# After transferring ownership of tokens, we can withdraw them

withdraw1_data_stack = token_without_split_helper.withdraw_data_stack_generator(swap2_contract_id, sender1.address, 1000)

withdraw2_data_stack = token_without_split_helper.withdraw_data_stack_generator(swap1_contract_id, sender2.address, 1000)

sender1.execute_contract(token2_contract_id, token_without_split_helper.withdraw_function_index, withdraw1_data_stack)

sender2.execute_contract(token1_contract_id, token_without_split_helper.withdraw_function_index, withdraw2_data_stack)
```
